# Comparing `tmp/atomicshop-1.6.8-py3-none-any.whl.zip` & `tmp/atomicshop-1.6.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,42 @@
-Zip file size: 60754 bytes, number of entries: 40
--rw-rw-rw-  2.0 fat      122 b- defN 23-Apr-05 16:25 atomicshop/__init__.py
--rw-rw-rw-  2.0 fat     3699 b- defN 23-Mar-27 09:18 atomicshop/_basics_temp.py
--rw-rw-rw-  2.0 fat     7215 b- defN 23-Mar-31 13:53 atomicshop/appointment_management.py
--rw-rw-rw-  2.0 fat     4763 b- defN 23-Mar-21 11:18 atomicshop/archiver.py
--rw-rw-rw-  2.0 fat     1038 b- defN 23-Feb-17 13:00 atomicshop/command_line_processing.py
--rw-rw-rw-  2.0 fat     1401 b- defN 23-Mar-31 13:57 atomicshop/console_output.py
--rw-rw-rw-  2.0 fat     3234 b- defN 23-Mar-26 17:45 atomicshop/console_user_response.py
--rw-rw-rw-  2.0 fat    13526 b- defN 23-Mar-26 18:16 atomicshop/datetimes.py
--rw-rw-rw-  2.0 fat      544 b- defN 23-Mar-24 15:04 atomicshop/dns.py
--rw-rw-rw-  2.0 fat     2864 b- defN 23-Mar-26 20:14 atomicshop/domains.py
--rw-rw-rw-  2.0 fat     1410 b- defN 23-Mar-26 20:18 atomicshop/emails.py
--rw-rw-rw-  2.0 fat    15009 b- defN 23-Mar-30 11:06 atomicshop/filesystem.py
--rw-rw-rw-  2.0 fat      509 b- defN 23-Mar-21 16:44 atomicshop/functions.py
--rw-rw-rw-  2.0 fat     4347 b- defN 23-Mar-26 20:30 atomicshop/github_wrapper.py
--rw-rw-rw-  2.0 fat     1742 b- defN 23-Mar-30 14:03 atomicshop/hashing.py
--rw-rw-rw-  2.0 fat     9703 b- defN 23-Mar-26 20:38 atomicshop/http_parse.py
--rw-rw-rw-  2.0 fat    11408 b- defN 23-Mar-27 09:17 atomicshop/inspect_wrapper.py
--rw-rw-rw-  2.0 fat      452 b- defN 22-Dec-20 20:45 atomicshop/keyboard_press.py
--rw-rw-rw-  2.0 fat     4574 b- defN 23-Mar-26 20:56 atomicshop/pbtkmultifile_argparse.py
--rw-rw-rw-  2.0 fat      522 b- defN 23-Apr-05 12:51 atomicshop/permissions.py
--rw-rw-rw-  2.0 fat     8882 b- defN 23-Apr-04 09:51 atomicshop/print_api.py
--rw-rw-rw-  2.0 fat     6899 b- defN 23-Mar-26 21:03 atomicshop/process.py
--rw-rw-rw-  2.0 fat     5373 b- defN 23-Apr-05 13:39 atomicshop/process_poller.py
--rw-rw-rw-  2.0 fat     4464 b- defN 23-Mar-21 11:48 atomicshop/python_functions.py
--rw-rw-rw-  2.0 fat      841 b- defN 23-Mar-31 13:42 atomicshop/question_answer_engine.py
--rw-rw-rw-  2.0 fat     2446 b- defN 23-Mar-26 21:06 atomicshop/scheduling.py
--rw-rw-rw-  2.0 fat     1643 b- defN 23-Mar-21 11:53 atomicshop/script_as_string_processor.py
--rw-rw-rw-  2.0 fat    19694 b- defN 23-Apr-02 09:00 atomicshop/sound.py
--rw-rw-rw-  2.0 fat     2735 b- defN 23-Mar-31 14:06 atomicshop/speech_recognize.py
--rw-rw-rw-  2.0 fat    16590 b- defN 23-Apr-04 00:03 atomicshop/ssh_remote.py
--rw-rw-rw-  2.0 fat      906 b- defN 23-Mar-26 21:16 atomicshop/sys_functions.py
--rw-rw-rw-  2.0 fat     2517 b- defN 23-Apr-02 09:00 atomicshop/tempfiles.py
--rw-rw-rw-  2.0 fat     1550 b- defN 23-Mar-22 09:28 atomicshop/timer.py
--rw-rw-rw-  2.0 fat      625 b- defN 23-Feb-14 20:34 atomicshop/urls.py
--rw-rw-rw-  2.0 fat     6959 b- defN 23-Mar-30 13:54 atomicshop/web.py
--rw-rw-rw-  2.0 fat     1094 b- defN 23-Apr-05 16:26 atomicshop-1.6.8.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     8727 b- defN 23-Apr-05 16:26 atomicshop-1.6.8.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-05 16:26 atomicshop-1.6.8.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       11 b- defN 23-Apr-05 16:26 atomicshop-1.6.8.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     3301 b- defN 23-Apr-05 16:26 atomicshop-1.6.8.dist-info/RECORD
-40 files, 183431 bytes uncompressed, 55528 bytes compressed:  69.7%
+Zip file size: 61896 bytes, number of entries: 40
+-rw-rw-rw-  2.0 fat      122 b- defN 23-Apr-09 11:22 atomicshop/__init__.py
+-rw-rw-rw-  2.0 fat     3699 b- defN 23-Mar-31 14:38 atomicshop/_basics_temp.py
+-rw-rw-rw-  2.0 fat     7215 b- defN 23-Mar-31 14:38 atomicshop/appointment_management.py
+-rw-rw-rw-  2.0 fat     4763 b- defN 23-Mar-31 14:38 atomicshop/archiver.py
+-rw-rw-rw-  2.0 fat     1038 b- defN 23-Mar-31 14:38 atomicshop/command_line_processing.py
+-rw-rw-rw-  2.0 fat     1372 b- defN 23-Apr-09 11:20 atomicshop/console_output.py
+-rw-rw-rw-  2.0 fat     3234 b- defN 23-Mar-31 14:38 atomicshop/console_user_response.py
+-rw-rw-rw-  2.0 fat    13526 b- defN 23-Mar-31 14:38 atomicshop/datetimes.py
+-rw-rw-rw-  2.0 fat      544 b- defN 23-Mar-31 14:38 atomicshop/dns.py
+-rw-rw-rw-  2.0 fat     2864 b- defN 23-Mar-31 14:38 atomicshop/domains.py
+-rw-rw-rw-  2.0 fat     1410 b- defN 23-Mar-31 14:38 atomicshop/emails.py
+-rw-rw-rw-  2.0 fat    15009 b- defN 23-Mar-31 14:38 atomicshop/filesystem.py
+-rw-rw-rw-  2.0 fat      509 b- defN 23-Mar-31 14:38 atomicshop/functions.py
+-rw-rw-rw-  2.0 fat     4347 b- defN 23-Mar-31 14:38 atomicshop/github_wrapper.py
+-rw-rw-rw-  2.0 fat     1742 b- defN 23-Mar-31 14:38 atomicshop/hashing.py
+-rw-rw-rw-  2.0 fat     9703 b- defN 23-Mar-31 14:38 atomicshop/http_parse.py
+-rw-rw-rw-  2.0 fat    11408 b- defN 23-Mar-31 14:38 atomicshop/inspect_wrapper.py
+-rw-rw-rw-  2.0 fat      452 b- defN 23-Mar-31 14:38 atomicshop/keyboard_press.py
+-rw-rw-rw-  2.0 fat     4574 b- defN 23-Mar-31 14:38 atomicshop/pbtkmultifile_argparse.py
+-rw-rw-rw-  2.0 fat      522 b- defN 23-Apr-05 16:35 atomicshop/permissions.py
+-rw-rw-rw-  2.0 fat     8878 b- defN 23-Apr-06 13:47 atomicshop/print_api.py
+-rw-rw-rw-  2.0 fat     6899 b- defN 23-Mar-31 14:38 atomicshop/process.py
+-rw-rw-rw-  2.0 fat     5373 b- defN 23-Apr-05 16:35 atomicshop/process_poller.py
+-rw-rw-rw-  2.0 fat     4464 b- defN 23-Mar-31 14:38 atomicshop/python_functions.py
+-rw-rw-rw-  2.0 fat      841 b- defN 23-Mar-31 14:38 atomicshop/question_answer_engine.py
+-rw-rw-rw-  2.0 fat     2446 b- defN 23-Mar-31 14:38 atomicshop/scheduling.py
+-rw-rw-rw-  2.0 fat     1643 b- defN 23-Mar-31 14:38 atomicshop/script_as_string_processor.py
+-rw-rw-rw-  2.0 fat    23115 b- defN 23-Apr-06 15:18 atomicshop/sound.py
+-rw-rw-rw-  2.0 fat     3837 b- defN 23-Apr-08 22:44 atomicshop/speech_recognize.py
+-rw-rw-rw-  2.0 fat    16590 b- defN 23-Apr-05 16:35 atomicshop/ssh_remote.py
+-rw-rw-rw-  2.0 fat      906 b- defN 23-Mar-31 14:38 atomicshop/sys_functions.py
+-rw-rw-rw-  2.0 fat     2517 b- defN 23-Apr-02 00:08 atomicshop/tempfiles.py
+-rw-rw-rw-  2.0 fat     1550 b- defN 23-Mar-31 14:38 atomicshop/timer.py
+-rw-rw-rw-  2.0 fat      625 b- defN 23-Mar-31 14:38 atomicshop/urls.py
+-rw-rw-rw-  2.0 fat     6959 b- defN 23-Mar-31 14:38 atomicshop/web.py
+-rw-rw-rw-  2.0 fat     1094 b- defN 23-Apr-09 11:23 atomicshop-1.6.9.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     8727 b- defN 23-Apr-09 11:23 atomicshop-1.6.9.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-09 11:23 atomicshop-1.6.9.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       11 b- defN 23-Apr-09 11:23 atomicshop-1.6.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     3301 b- defN 23-Apr-09 11:23 atomicshop-1.6.9.dist-info/RECORD
+40 files, 187921 bytes uncompressed, 56670 bytes compressed:  69.8%
```

## zipnote {}

```diff
@@ -99,23 +99,23 @@
 
 Filename: atomicshop/urls.py
 Comment: 
 
 Filename: atomicshop/web.py
 Comment: 
 
-Filename: atomicshop-1.6.8.dist-info/LICENSE.txt
+Filename: atomicshop-1.6.9.dist-info/LICENSE.txt
 Comment: 
 
-Filename: atomicshop-1.6.8.dist-info/METADATA
+Filename: atomicshop-1.6.9.dist-info/METADATA
 Comment: 
 
-Filename: atomicshop-1.6.8.dist-info/WHEEL
+Filename: atomicshop-1.6.9.dist-info/WHEEL
 Comment: 
 
-Filename: atomicshop-1.6.8.dist-info/top_level.txt
+Filename: atomicshop-1.6.9.dist-info/top_level.txt
 Comment: 
 
-Filename: atomicshop-1.6.8.dist-info/RECORD
+Filename: atomicshop-1.6.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## atomicshop/__init__.py

```diff
@@ -1,4 +1,4 @@
 """Atomic Basic functions and classes to make developer life easier"""
 
 __author__ = "Den Kras"
-__version__ = '1.6.8'
+__version__ = '1.6.9'
```

## atomicshop/console_output.py

```diff
@@ -1,8 +1,7 @@
-# v1.0.0 - 31.03.2023 17:00
 import contextlib
 import io
 
 
 class TempDisableOutput:
     """
     The class was built to use with 'with' statement in order to temporarily disable output to console for function
```

## atomicshop/print_api.py

```diff
@@ -166,15 +166,15 @@
         Line 2: 'Skipped Empty bytes: 200 / 1000'
         Line 3: 'Downloaded bytes: 300 / 1000    '
     :param kwargs: keyword arguments to pass to 'print_api' function.
     :return: None
     """
 
     if final_state:
-        message = f'{prefix_string}: {current_state} / {final_state}{suffix_string}'
+        message = f'{prefix_string}{current_state} / {final_state}{suffix_string}'
     else:
-        message = f'{prefix_string}: {current_state}{suffix_string}'
+        message = f'{prefix_string}{current_state}{suffix_string}'
 
     if same_line:
         print_api(message, print_end='\r', **kwargs)
     else:
         print_api(message, **kwargs)
```

## atomicshop/sound.py

```diff
@@ -1,14 +1,14 @@
-# v1.0.1 - 02.04.2023 02:50
 import io
 import queue
 import threading
 
 from .print_api import print_api, print_status
 from .wrappers import numpyw
+from .basics import numbers
 
 import soundcard
 import soundfile
 
 
 def get_inputs(include_loopback: bool = False, **kwargs):
     """
@@ -123,14 +123,73 @@
     # and not 'None', then return a list with selected interface only.
     if input_loopback_list and isinstance(select_interface, int):
         input_loopback_list = [input_loopback_list[select_interface]]
 
     return input_loopback_list
 
 
+def open_byteio_soundfile(samplerate: int = 44100, bit_rate: str = 'PCM_16'):
+    byte_io = io.BytesIO()
+    # In order for the 'soundfile' library to recognize the 'io.BytesIO' object as a file,
+    # we need to give it a name with extension of '.wav'.
+    # byte_io.name = 'test.wav'
+    # Or we can use the "format='WAV'" parameter.
+    output_memory = soundfile.SoundFile(
+        byte_io, mode='w', samplerate=samplerate, channels=2, subtype=bit_rate, format='WAV')
+
+    return output_memory
+
+
+def close_byteio_soundfile():
+    return
+
+
+class ByteIOSoundFile:
+    def __init__(self, samplerate: int = 44100, bit_rate: str = 'PCM_16', return_type: str = 'file'):
+        """
+
+        :param samplerate: int, default 44100.
+        :param bit_rate: str, default 'PCM_16'.
+        :param return_type: string, return type of the 'ByteIOSoundFile' object on 'close()' method.
+            Default is 'file'. Available:
+                'file' - return the 'io.BytesIO' object.
+                'bytes' - return the 'io.BytesIO' object as bytes.
+        """
+
+        self.samplerate: int = samplerate
+        self.bit_rate: str = bit_rate
+        self.return_type: str = return_type
+
+        self.byte_io = None
+        self.output_memory = None
+
+    def open(self):
+        self.byte_io = io.BytesIO()
+        # In order for the 'soundfile' library to recognize the 'io.BytesIO' object as a file,
+        # we need to give it a name with extension of '.wav'.
+        # byte_io.name = 'test.wav'
+        # Or we can use the "format='WAV'" parameter.
+        self.output_memory = soundfile.SoundFile(
+            self.byte_io, mode='w', samplerate=self.samplerate, channels=2, subtype=self.bit_rate, format='WAV')
+
+    def write(self, data):
+        self.output_memory.write(data)
+
+    def close(self):
+        self.output_memory.close()
+        self.byte_io.seek(0)
+
+        if self.return_type == 'file':
+            # Return the 'io.BytesIO' object as is.
+            return self.byte_io
+        elif self.return_type == 'bytes':
+            # Convert the 'io.BytesIO' object to bytes.
+            return self.byte_io.read()
+
+
 class StereoMixRecorder:
     def __init__(
             self, samplerate: int = 44100, bit_rate: str = 'PCM_16', buffer_size: int = 1024,
             skip_empty_buffers: bool = False, use_first_loopback: bool = True, select_interface=None):
         """
         :param samplerate: integer, sample rate of the wave that will be recorded. The default is '44100', since regular
             audio wav files for listening are this quality.
@@ -179,113 +238,176 @@
         # If no loopback interfaces were found.
         elif not loopback_inputs:
             raise RuntimeError("Loopback input interface wasn't found.")
 
         return loopback_inputs[0]
 
     def start(
-            self, file_path: str = str(), emit_type: str = None, cut_emit_buffers: int = None,
-            record_until_zero_array: bool = False, **kwargs):
+            self, split_emit_buffers: int = None, emit_type: str = None, file_path: str = None,
+            record_until_zero_array: bool = False, seconds: int = None, **kwargs):
         """
         The function will start recording from stereo mix loopback in the sound driver.
 
-        :param file_path: string, full file path to '.wav' file to save. Default is empty string, meaning that no file
-            will be saved.
+        :param split_emit_buffers: integer/None, amount of buffers to emit.
+            The default is None.
+            None: all the buffers will be emitted when record 'stop()'s.
+            1: meaning that each buffer will be emitted as it enters from the 'soundcard' module.
+            2: meaning that every 2 buffers will be emitted as one, etc.
         :param emit_type: string, the type of the emitted data through 'emit()' method. The default is None.
             Currently supported:
                 None: no data will be emitted, meaning that 'emit()' method will be disabled.
                 'byteio': 'io.BytesIO' object - file object that will contain the same data that is stored in actual
                     '.wav' file.
                 'nparray': float64 numpy array.
-        :param cut_emit_buffers: integer, amount of buffers to emit. applicable only for 'emit_type='byteio'.
-            The default is None, meaning that all the buffers will be emitted when record finishes.
+        :param file_path: string, full file path to '.wav' file to save. Default is None, meaning that no file
+            will be saved.
+        :param record_until_zero_array: boolean, record until the numpy array output from 'record()' method
+            is all zeros. The default is 'False'.
+            This happens when nothing is playing in the stereo mix.
+            If this parameter is 'True', the recording will stop when the playback in stereo mix will stop.
+        :param seconds: integer, amount of seconds to record. The default is None, meaning that the recording will
+            continue until the 'stop()' method is called.
         :param kwargs:
         :return:
         """
 
+        if not file_path and not emit_type:
+            raise ValueError("Either 'file_path' or 'emit_type' must be specified.")
+
         self.recording = True
         threading.Thread(
             target=self._thread_record,
-            args=(file_path, emit_type, cut_emit_buffers, record_until_zero_array),
+            args=(split_emit_buffers, emit_type, file_path, record_until_zero_array, seconds),
             kwargs=kwargs
         ).start()
 
     def _thread_record(
-            self, file_path: str, emit_type: str, cut_emit_buffers: int, record_until_zero_array: bool, **kwargs):
-        # # Getting the total number of buffers.
-        # total_frames = seconds * self.samplerate
+            self, split_emit_buffers: int, emit_type: str, file_path: str, record_until_zero_array: bool, seconds,
+            **kwargs):
         # Currently no frames were recorded.
         recorded_frames = 0
 
+        # If the 'file_path' was specified, then wav file will be written to it.
         output_file = None
         if file_path:
             output_file = soundfile.SoundFile(
                 file_path, mode='w', samplerate=self.samplerate, channels=2, subtype=self.bit_rate)
 
-        output_memory = None
-        byte_io = None
+        # If the 'emit_type' of 'byteio' was specified, then the data will be emitted as 'io.BytesIO' object,
+        # containing bytes of the recorded audio as WAV.
+        byteio_soundfile = None
+        data_nparray_buffer_list = None
         if emit_type == 'byteio':
-            byte_io = io.BytesIO()
-            # byte_io.name = 'test.wav'
-            output_memory = soundfile.SoundFile(
-                byte_io, mode='w', samplerate=self.samplerate, channels=2, subtype=self.bit_rate, format='WAV')
+            byteio_soundfile = ByteIOSoundFile(self.samplerate, self.bit_rate)
+            byteio_soundfile.open()
+        elif emit_type == 'nparray':
+            data_nparray_buffer_list = list()
+
+        total_frames = None
+        if seconds:
+            # Getting the total number of buffers.
+            total_frames = seconds * self.samplerate
+
+            # If the total amount of frames is not divisible by the buffer size, this means that the last buffer
+            # will be smaller than the rest of the buffers. To avoid this, we will add the buffer size to the total
+            # amount of frames, so that the last buffer will be the same size as the rest of the buffers.
+
+            # To do that we'll divide the total amount of frames by the buffer size, to know how many buffers there
+            # are, this number will be converted to int to drop all the numbers after the '.' dot.
+            # Then multiply it by the buffer size, to get the total amount of frames without the last buffer.
+            # Then add the buffer size to get the total amount of frames with the last buffer.
+            if not numbers.is_divisible(total_frames, self.buffer_size):
+                total_frames = int(total_frames/self.buffer_size)*self.buffer_size + self.buffer_size
+
+            message = f"Record will stop after: [{seconds}] Seconds, [{total_frames}] Frames"
+            print_api(message)
 
         emit_buffers_counter = 0
         # Use first input interface (with only 1 interface in the list at this stage).
         with self.loopback_input.recorder(samplerate=self.samplerate) as input_interface:
             # Record while the amount of recorded frames is not equal to the final total amount of frames.
             while self.recording:
+                # If the 'seconds' parameter was specified, and the total amount of recorded frames is equal to
+                # the total amount of frames, then stop recording.
+                if seconds and recorded_frames == total_frames:
+                    self.stop()
+
                 emit_buffers_counter += 1
                 # print(emit_buffers_counter)
                 # Record audio data from selected loopback input interface for 'buffer_size' amount of frames.
-                data = input_interface.record(numframes=self.buffer_size)
-                if emit_type == 'nparray':
-                    self._buffer_queue.put(data)
+                data_nparray = input_interface.record(numframes=self.buffer_size)
 
+                # Aggregating the total amount of recorded frames as integer.
                 recorded_frames = recorded_frames + self.buffer_size
 
-                if record_until_zero_array and self._some_data_was_recorded and numpyw.check_if_array_is_empty(data):
+                # If 'record_until_zero_array' is 'True' and the buffer is empty, and some data was already present in
+                # previous cycle - stop recording.
+                if record_until_zero_array and self._some_data_was_recorded and numpyw.is_array_empty(data_nparray):
                     self.stop()
 
                 # If 'skip_empty_buffers' is 'True' and the buffer is empty, skip it.
-                if self.skip_empty_buffers and numpyw.check_if_array_is_empty(data):
+                if self.skip_empty_buffers and numpyw.is_array_empty(data_nparray):
                     print_status(True, 'Skipping Empty Frames', recorded_frames, None, color="yellow")
                 # If the buffer is not empty, write it to the wave file.
                 else:
-                    if not numpyw.check_if_array_is_empty(data):
+                    # If the buffer is not empty, set the flag to 'True'.
+                    if not numpyw.is_array_empty(data_nparray):
                         self._some_data_was_recorded = True
 
+                    # Write the data to the file and/or to the memory ByteIO object/numpy array list.
                     if file_path:
-                        output_file.write(data)
+                        output_file.write(data_nparray)
+
                     if emit_type == 'byteio':
-                        output_memory.write(data)
+                        byteio_soundfile.write(data_nparray)
+                    elif emit_type == 'nparray':
+                        data_nparray_buffer_list.append(data_nparray)
 
                     print_status(
-                        True, 'Recorded Seconds | Frames', f'[{recorded_frames / self.samplerate} | {recorded_frames}]',
+                        True,
+                        'Recorded: Seconds | Frames: ', f'[{recorded_frames / self.samplerate} | {recorded_frames}]',
                         None, suffix_string='         ', **kwargs)
 
-                    if cut_emit_buffers:
-                        if emit_buffers_counter == cut_emit_buffers:
-                            output_memory.close()
-                            byte_io.seek(0)
-                            emit_bytes = byte_io.read()
-                            self._buffer_queue.put(emit_bytes)
-                            byte_io = io.BytesIO()
-                            # byte_io.name = 'test.wav'
-                            output_memory = soundfile.SoundFile(
-                                byte_io, mode='w', samplerate=self.samplerate, channels=2, subtype=self.bit_rate,
-                                format='WAV')
+                    # If the 'split_emit_buffers' was specified, emit the data in chunks.
+                    if split_emit_buffers:
+                        # If the counter reached the split amount, emit the data.
+                        if emit_buffers_counter == split_emit_buffers:
+                            # Reset the counter.
+                            emit_buffers_counter = 0
+
+                            if emit_type == 'byteio':
+                                # Emit the data and close the SoundFile and ByteIO object.
+                                emit_bytes = byteio_soundfile.close()
+                                self._buffer_queue.put(emit_bytes)
+                                # Open new SoundFile and ByteIO object.
+                                byteio_soundfile.open()
+                            elif emit_type == 'nparray':
+                                # If 'split_emit_buffers' is 1, then emit the data as is.
+                                if split_emit_buffers == 1:
+                                    self._buffer_queue.put(data_nparray)
+                                # If 'split_emit_buffers' is more than 1, then concatenate the list of data arrays
+                                # and emit it.
+                                else:
+                                    self._buffer_queue.put(numpyw.concatenate_array_list(data_nparray_buffer_list))
+                                    # Clear the list.
+                                    data_nparray_buffer_list = list()
 
+        # ==============================================================================================================
+        # At this point the recording has stopped.
+
+        # If the 'file_path' was specified, then rest of the wav file will be written to it.
         if file_path:
             output_file.close()
+        # If the 'emit_type' of 'byteio' was specified, then the data will be emitted as 'io.BytesIO' object,
+        # and emit to buffer queue.
         if emit_type == 'byteio':
-            output_memory.close()
-            byte_io.seek(0)
-            emit_bytes = byte_io.read()
+            emit_bytes = byteio_soundfile.close()
             self._buffer_queue.put(emit_bytes)
+        elif emit_type == 'nparray':
+            self._buffer_queue.put(numpyw.concatenate_array_list(data_nparray_buffer_list))
 
     def stop(self):
         """
         The function will stop recording from stereo mix loopback in the sound driver.
 
         :return: None.
         """
@@ -303,114 +425,64 @@
         If 'emit_type' is 'nparray', the function will return 'float64' numpy array.
 
         :return: 'bytes' wav file object or 'float64' numpy array.
         """
 
         return self._buffer_queue.get()
 
-    def record_stereo_mix(self, file_path: str, seconds: int, **kwargs):
-        """
-        The function will record from stereo mix loopback in the sound driver for specified amount of time.
-
-        :param file_path: string, full file path to '.wav' file to save.
-        :param seconds: integer, amount of seconds to record.
-        :param kwargs: parameters for 'print_api'.
-        :return: None.
-        """
-
-        # Getting the total number of buffers.
-        total_frames = seconds * self.samplerate
-        # Currently no frames were recorded.
-        recorded_frames = 0
-
-        # Open the output file.
-        with soundfile.SoundFile(
-                file_path, mode='w', samplerate=self.samplerate, channels=2, subtype=self.bit_rate) as output_file:
-            # Use first input interface (with only 1 interface in the list at this stage).
-            with self.loopback_input.recorder(samplerate=self.samplerate) as input_interface:
-                message = f'Recording Seconds: [{seconds}]. ' \
-                          f'Buffer size (frames): [{self.buffer_size}]. ' \
-                          f'Total Frames: [{total_frames}].'
-                print_api(message, **kwargs)
-
-                # Record while the amount of recorded frames is not equal to the final total amount of frames.
-                while recorded_frames != total_frames:
-                    frames_left = total_frames - recorded_frames
-                    same_line = True
-                    # If the amount of frames left is less than the buffer size that was set in the beginning,
-                    # it means that we are in the last buffer, and we need to set the buffer size to the amount
-                    # of frames left and also set 'same_line' to 'False' so that the prints after that will be printed
-                    # in a new line.
-                    if frames_left <= buffer_size:
-                        same_line = False
-                        buffer_size = frames_left
-
-                    # Record audio data from selected loopback input interface for 'buffer_size' amount of frames.
-                    data = input_interface.record(numframes=buffer_size)
-
-                    recorded_frames = recorded_frames + buffer_size
-
-                    # If 'skip_empty_buffers' is 'True' and the buffer is empty, skip it.
-                    if self.skip_empty_buffers and numpyw.check_if_array_is_empty(data):
-                        print_status(same_line, 'Skipping Empty Frames', recorded_frames, total_frames, color="yellow")
-                    # If the buffer is not empty, write it to the wave file.
-                    else:
-                        output_file.write(data)
-                        print_status(
-                            same_line, 'Recorded Frames', recorded_frames, total_frames, suffix_string='         ')
 
-    """
-    Recording comments:
-    1. Tried to use 'wave' built-in library, It can write buffer chunks to wave file - you don't have to write
-    the whole numpy array at once. Since, 'soundcard' library returns 'float64' numpy array, you have to convert
-    it to 'int16' numpy array before recording it to wave file or you will get noise while saving to 16 bit wave file.
-    Only after converting to 'int16' numpy array, you can convert numpy array to bytes and write it to wave file.
-    This gave me clipped distorted wave file for some reason.
-    
-    Usage:
-    import wave
-    with wave.open(file_path, "w") as output_file:
-        # 2 Channels.
-        output_file.setnchannels(2)
-        # Sample width is bit rate, just in bytes. Meaning, 16-bit bitrate is 2 bytes samplewidth.
-        # output_file.setsampwidth(2)
-        # Or you can just divide the bitrate by 8, to get bytes for sample width.
-        output_file.setsampwidth(bitrate/8)
-        output_file.setframerate(samplerate)
-        
-        # Recording loop.
-        while True:
-            # Get the float64 numpy array of recorded data.
-            data = input_interface.record(numframes=buffer_size)
-            # Convert the numpy array to int16 numpy array.
-            data = numpyw.convert_float64_to_int16(data)
-            # Write the data to wave file, while converting numpy array to bytes.
-            output_file.writeframes(numpyw.convert_array_to_bytes(data))
-            
-    2. Tried to use 'scipy.io.wavfile.write', this worked fine, but it requires the whole numpy array to be recorded
-    at once. Scipy doesn't support writing buffer chunks to wave file. And, the same applies here, you have to convert
-    the 'float64' numpy array to 'int16' numpy array before recording it to wave file or you will get noise while 
-    saving to 16 bit wave file.
-    
-    Usage:
-    from scipy.io.wavfile import write
-    
-    # 'buffer_list' will store the recorded data.
-    buffer_list: list = list()
+"""
+Recording comments:
+1. Tried to use 'wave' built-in library, It can write buffer chunks to wave file - you don't have to write
+the whole numpy array at once. Since, 'soundcard' library returns 'float64' numpy array, you have to convert
+it to 'int16' numpy array before recording it to wave file or you will get noise while saving to 16 bit wave file.
+Only after converting to 'int16' numpy array, you can convert numpy array to bytes and write it to wave file.
+This gave me clipped distorted wave file for some reason.
+
+Usage:
+import wave
+with wave.open(file_path, "w") as output_file:
+    # 2 Channels.
+    output_file.setnchannels(2)
+    # Sample width is bit rate, just in bytes. Meaning, 16-bit bitrate is 2 bytes samplewidth.
+    # output_file.setsampwidth(2)
+    # Or you can just divide the bitrate by 8, to get bytes for sample width.
+    output_file.setsampwidth(bitrate/8)
+    output_file.setframerate(samplerate)
     
     # Recording loop.
     while True:
         # Get the float64 numpy array of recorded data.
         data = input_interface.record(numframes=buffer_size)
         # Convert the numpy array to int16 numpy array.
         data = numpyw.convert_float64_to_int16(data)
-        # Append the data to buffer list.
-        buffer_list.append(data)
+        # Write the data to wave file, while converting numpy array to bytes.
+        output_file.writeframes(numpyw.convert_array_to_bytes(data))
         
-    # Concatenate the numpy arrays in the buffer list.
-    concatenated_numpy_array = numpyw.concatenate_numpy_arrays(buffer_list)
-    # Write the wave file with 'scipy'.
-    write(file_path, samplerate, concatenated_numpy_array)
+2. Tried to use 'scipy.io.wavfile.write', this worked fine, but it requires the whole numpy array to be recorded
+at once. Scipy doesn't support writing buffer chunks to wave file. And, the same applies here, you have to convert
+the 'float64' numpy array to 'int16' numpy array before recording it to wave file or you will get noise while 
+saving to 16 bit wave file.
+
+Usage:
+from scipy.io.wavfile import write
+
+# 'buffer_list' will store the recorded data.
+buffer_list: list = list()
+
+# Recording loop.
+while True:
+    # Get the float64 numpy array of recorded data.
+    data = input_interface.record(numframes=buffer_size)
+    # Convert the numpy array to int16 numpy array.
+    data = numpyw.convert_float64_to_int16(data)
+    # Append the data to buffer list.
+    buffer_list.append(data)
     
-    3. Finally 'soundfile' library, was the only one that converts the 'float64' numpy array to 'int16' numpy array
-    automatically, and also supports writing buffer chunks to wave file. So, this is the best option. 
-    """
+# Concatenate the numpy arrays in the buffer list.
+concatenated_numpy_array = numpyw.concatenate_numpy_arrays(buffer_list)
+# Write the wave file with 'scipy'.
+write(file_path, samplerate, concatenated_numpy_array)
+
+3. Finally 'soundfile' library, was the only one that converts the 'float64' numpy array to 'int16' numpy array
+automatically, and also supports writing buffer chunks to wave file. So, this is the best option. 
+"""
```

## atomicshop/speech_recognize.py

```diff
@@ -1,36 +1,59 @@
-# v1.0.1 - 31.03.2023 17:00
 from .wrappers.ffmpegw import FFmpegWrapper
 from .tempfiles import TempFile
 from atomicshop.web import download_with_urllib
 
 
-def get_text_from_wav(wav_file_path: str) -> str:
+def get_text_from_wav(wav_file_path: str, engine: str = "google", adjust_for_ambient_noise: bool = False) -> str:
     """
     The function recognizes speech in source WAV file and returns recognized text.
 
     :param wav_file_path: string, full file path to WAV file.
+    :param engine: string, offline speech recognition engine, default is 'google'. Available engines:
+        'google', 'sphinx', 'tensorflow', 'whisper', 'vosk'.
+    :param adjust_for_ambient_noise: bool, if True, will adjust for ambient noise before recognizing.
+        Default is False.
     :return: string, recognized text from WAV file.
     """
 
     # Lazy import.
     from speech_recognition import Recognizer, AudioFile
 
     # Initialize speech recognizer classes.
     speech_recognizer = Recognizer()
     # Import wav file.
     speech_recognizer_recaptcha_audio = AudioFile(wav_file_path)
     # Process the file.
     with speech_recognizer_recaptcha_audio as source:
+        # If 'adjust_for_ambient_noise' is True, will adjust for ambient noise before recognizing.
+        if adjust_for_ambient_noise:
+            speech_recognizer.adjust_for_ambient_noise(source)
+
         audio = speech_recognizer.record(source)
     # Convert to text.
     # When using 'recognize_google' it outputs debugging JSON, there's an option 'show_all=False',
     # which is set by default, could be a bug in current version 3.9.0. There are some changes in GitHub for it
     # but not in PyPi, will wait.
-    text = speech_recognizer.recognize_google(audio)
+
+    text = str()
+    if engine == "google":
+        text = speech_recognizer.recognize_google(audio)
+    elif engine == "sphinx":
+        # pip install pocketsphinx
+        text = speech_recognizer.recognize_sphinx(audio)
+    elif engine == "tensorflow":
+        # pip install tensorflow
+        text = speech_recognizer.recognize_tensorflow(audio)
+    elif engine == "whisper":
+        # pip install torch
+        # pip install whisper
+        text = speech_recognizer.recognize_whisper(audio)
+    elif engine == "vosk":
+        # pip install vosk
+        text = speech_recognizer.recognize_vosk(audio)
 
     return text
 
 
 def convert_mp3_and_get_text(mp3_file_path: str, wav_file_path: str) -> str:
     """
     The function will convert source MP3 file to destination WAV file and get text from the converted WAV file.
```

## Comparing `atomicshop-1.6.8.dist-info/LICENSE.txt` & `atomicshop-1.6.9.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `atomicshop-1.6.8.dist-info/METADATA` & `atomicshop-1.6.9.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: atomicshop
-Version: 1.6.8
+Version: 1.6.9
 Summary: Atomic functions and classes to make developer life easier
 Author: Denis Kras
 License: MIT License
         
         Copyright (c) 2023 Bugsec, Denis Kras
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
```

## Comparing `atomicshop-1.6.8.dist-info/RECORD` & `atomicshop-1.6.9.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-atomicshop/__init__.py,sha256=XkB10Q__HKy77qwHXYiEW6XaILDMAHTJ4io8NwDfX20,122
+atomicshop/__init__.py,sha256=35na1M0VBDbDcnyaLAQdDblPOIvq-x-SjLbVjnf5okE,122
 atomicshop/_basics_temp.py,sha256=6cu2dd6r2dLrd1BRNcVDKTHlsHs_26Gpw8QS6v32lQ0,3699
 atomicshop/appointment_management.py,sha256=PlE6r315_w-b2nK3CVFdincHnPDNbSEggA_bvpQQyYU,7215
 atomicshop/archiver.py,sha256=KKdNI150yiMO_Y1TZdKjXtw4TP5LI5FJzI8VbvFKVwo,4763
 atomicshop/command_line_processing.py,sha256=u5yT9Ger_cu7ni5ID0VFlRbVD46ARHeNC9tRM-_YXrQ,1038
-atomicshop/console_output.py,sha256=TyKxM8Q5VfFm22xDiXkHWVTSx8Y8QAQZMTg5io6WZZs,1401
+atomicshop/console_output.py,sha256=G-6jxnWooT1nJSaPxcCqIuw8S22R_0lOJcfrdovRhwE,1372
 atomicshop/console_user_response.py,sha256=31HIy9QGXa7f-GVR8MzJauQ79E_ZqAeagF3Ks4GGdDU,3234
 atomicshop/datetimes.py,sha256=kyB8h5LtC6BDD-rJphps3rtJprsIHhQwaWXfW7WfIqU,13526
 atomicshop/dns.py,sha256=GYuIrayT-SlCET_Ge2Ty7CObtVXL4eKDA-U5SkNGYzE,544
 atomicshop/domains.py,sha256=sbH5C_NX1_9CrLo2Mt8rFHzHbhJOwiW8JYSIN4CD6ps,2864
 atomicshop/emails.py,sha256=I0KyODQpIMEsNRi9YWSOL8EUPBiWyon3HRdIuSj3AEU,1410
 atomicshop/filesystem.py,sha256=L909rHvMBQdWU6XbhBXMEVVvo-OqUPErONtexUhoj2o,15009
 atomicshop/functions.py,sha256=VqLjxAxhaxUr-Ad8P1cw9bZGdZpbtqfCaXQyHf3CM9g,509
 atomicshop/github_wrapper.py,sha256=7pZkhliP4vdcdeVtbgTDEzBS3lUw3-mp5PMWUDA19V0,4347
 atomicshop/hashing.py,sha256=VfT1RePKeEMBlmAxKXHFM3nPSVTAttwT1vRdpWQmIEE,1742
 atomicshop/http_parse.py,sha256=nrf2rZcprLqtW8HVrV7TCZ1iTBcWRRy-mXIlAOzcaJs,9703
 atomicshop/inspect_wrapper.py,sha256=_nAEJzG337_UoI3BN_RvcIptjcN_Tc6wWotVwVCwy68,11408
 atomicshop/keyboard_press.py,sha256=1W5kRtOB75fulVx-uF2yarBhW0_IzdI1k73AnvXstk0,452
 atomicshop/pbtkmultifile_argparse.py,sha256=aEk8nhvoQVu-xyfZosK3ma17CwIgOjzO1erXXdjwtS4,4574
 atomicshop/permissions.py,sha256=CYTDVOI0jh9ks0ZLnnOuPzppgCszFEc9-92DTkVTYi4,522
-atomicshop/print_api.py,sha256=9e8kyP_ma2wS817zJUjSJ2KXHZKHtn-y6qXmtMgkya0,8882
+atomicshop/print_api.py,sha256=Qm23wFrQqoVGrYaAj-acbyoFxKJDqEsl_CYYSXGxeyk,8878
 atomicshop/process.py,sha256=Za3kgoLHhaWGYrc1RIeOk2Z0ulsIEQXDfKRVwIAW4_w,6899
 atomicshop/process_poller.py,sha256=fBLA6oiEmcOCjfkIH9a15ulS9MSzMT4jxutAvDNhFLk,5373
 atomicshop/python_functions.py,sha256=onZ272J1IiSQToqdzEvvWAFHe0EAJnNkAVv0mYkeNNw,4464
 atomicshop/question_answer_engine.py,sha256=DuOn7QEgKKfqZu2cR8mVeFIfFgayfBHiW-jY2VPq_Fo,841
 atomicshop/scheduling.py,sha256=mej1eQZkrrk7W4CWTjl5GEB6evqoYDfUMfc9fGbIH_k,2446
 atomicshop/script_as_string_processor.py,sha256=KJ5k_c0nccTyMXwbWIsovE7zWBFZD7QgD9GtdhMnmuo,1643
-atomicshop/sound.py,sha256=r-LE9ZzUXQX5WPCcSVaVqm6tz6A1aObRc4_A2WRxSso,19694
-atomicshop/speech_recognize.py,sha256=PQ5GyC9Ib8AwxCKF1zom34B4yvQ_XiKI8Ujcyix8ayU,2735
+atomicshop/sound.py,sha256=r-YUepjCus_Zq6p1iSgGOjta53XFoMkZRQWpNgFXkxc,23115
+atomicshop/speech_recognize.py,sha256=yWcrPYoHPY7BqTOuqXlQ8RUAhRW_7aVXpB4ApZfMKZk,3837
 atomicshop/ssh_remote.py,sha256=ZC8T_gLjNF-dBTl3BzDqcwJYiT92Ev23UF0qzT0t2sU,16590
 atomicshop/sys_functions.py,sha256=MTBxRve5bh58SPvhX3gMiGqHlSBuI_rdNN1NnnBBWqI,906
 atomicshop/tempfiles.py,sha256=uq1ve2WlWehZ3NOTXJnpBBMt6HyCdBufqedF0HyzA6k,2517
 atomicshop/timer.py,sha256=Xk4jA-TB8ICtpF63D06wVQNbzKbm0a66f4uTvBsMM1o,1550
 atomicshop/urls.py,sha256=2vVWXeue6NyuW-RHORrkSeJEl9tQM71rW8DC7_SnR6c,625
 atomicshop/web.py,sha256=fxK2UJCGSx_AJdUfUrP5gNvWZgHOXtIVTdlR24B1yvE,6959
-atomicshop-1.6.8.dist-info/LICENSE.txt,sha256=lLU7EYycfYcK2NR_1gfnhnRC8b8ccOTElACYplgZN88,1094
-atomicshop-1.6.8.dist-info/METADATA,sha256=UfCLd7Ys-1dj97icg7_mHeE2cBYKvtTT1zML41vqkYk,8727
-atomicshop-1.6.8.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-atomicshop-1.6.8.dist-info/top_level.txt,sha256=EgKJB-7xcrAPeqTRF2laD_Np2gNGYkJkd4OyXqpJphA,11
-atomicshop-1.6.8.dist-info/RECORD,,
+atomicshop-1.6.9.dist-info/LICENSE.txt,sha256=lLU7EYycfYcK2NR_1gfnhnRC8b8ccOTElACYplgZN88,1094
+atomicshop-1.6.9.dist-info/METADATA,sha256=Ni7KRFLDltGBaVPqq-nozBLLuAbE_QAu0ZYyAOKIKW4,8727
+atomicshop-1.6.9.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+atomicshop-1.6.9.dist-info/top_level.txt,sha256=EgKJB-7xcrAPeqTRF2laD_Np2gNGYkJkd4OyXqpJphA,11
+atomicshop-1.6.9.dist-info/RECORD,,
```

