# Comparing `tmp/py3traits-1.2.0-py2.py3-none-any.whl.zip` & `tmp/py3traits-1.2.1-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,35 +1,35 @@
-Zip file size: 42673 bytes, number of entries: 33
--rw-rw-rw-  2.0 fat     1735 b- defN 15-Jun-13 13:48 pytraits/combiner.py
--rw-rw-rw-  2.0 fat     2285 b- defN 15-Aug-16 19:01 pytraits/extendable.py
--rw-rw-rw-  2.0 fat     3461 b- defN 15-Aug-16 19:01 pytraits/setproperty.py
--rw-rw-rw-  2.0 fat     2111 b- defN 15-Aug-16 19:01 pytraits/trait_composer.py
--rw-rw-rw-  2.0 fat     1083 b- defN 15-Aug-16 19:01 pytraits/__init__.py
--rw-rw-rw-  2.0 fat      217 b- defN 15-Aug-16 19:01 pytraits/core/__init__.py
--rw-rw-rw-  2.0 fat     1873 b- defN 15-Aug-16 19:01 pytraits/core/base/inspectors.py
--rw-rw-rw-  2.0 fat     1020 b- defN 15-Aug-16 19:01 pytraits/core/base/__init__.py
--rw-rw-rw-  2.0 fat     3215 b- defN 15-Aug-16 19:01 pytraits/core/composing/compiler.py
--rw-rw-rw-  2.0 fat     5844 b- defN 15-Aug-16 19:01 pytraits/core/composing/composer.py
--rw-rw-rw-  2.0 fat     1741 b- defN 15-Aug-16 19:01 pytraits/core/composing/resolutions.py
--rw-rw-rw-  2.0 fat     3439 b- defN 15-Aug-16 19:01 pytraits/core/composing/traits.py
--rw-rw-rw-  2.0 fat      857 b- defN 15-Aug-16 19:01 pytraits/core/composing/__init__.py
--rw-rw-rw-  2.0 fat     1583 b- defN 15-Aug-16 19:01 pytraits/core/primitives/class_object.py
--rw-rw-rw-  2.0 fat     2942 b- defN 15-Aug-16 19:01 pytraits/core/primitives/instance_object.py
--rw-rw-rw-  2.0 fat     1796 b- defN 15-Aug-16 19:01 pytraits/core/primitives/property_object.py
--rw-rw-rw-  2.0 fat     4018 b- defN 15-Aug-16 19:01 pytraits/core/primitives/routine_object.py
--rw-rw-rw-  2.0 fat     1373 b- defN 15-Aug-16 19:01 pytraits/core/primitives/trait_object.py
--rw-rw-rw-  2.0 fat      951 b- defN 15-Aug-16 19:01 pytraits/core/primitives/unidentified_object.py
--rw-rw-rw-  2.0 fat     1799 b- defN 15-Aug-16 19:01 pytraits/core/primitives/__init__.py
--rw-rw-rw-  2.0 fat     1863 b- defN 15-Aug-16 19:01 pytraits/support/errors.py
--rw-rw-rw-  2.0 fat     5807 b- defN 15-Aug-16 19:01 pytraits/support/factory.py
--rw-rw-rw-  2.0 fat     9850 b- defN 15-Aug-16 19:01 pytraits/support/inspector.py
--rw-rw-rw-  2.0 fat    12085 b- defN 15-Aug-16 19:01 pytraits/support/magic.py
--rw-rw-rw-  2.0 fat     2302 b- defN 15-Aug-16 19:01 pytraits/support/singleton.py
--rw-rw-rw-  2.0 fat     4378 b- defN 15-Aug-16 19:01 pytraits/support/utils.py
--rw-rw-rw-  2.0 fat     1005 b- defN 15-Aug-16 19:01 pytraits/support/__init__.py
--rw-rw-rw-  2.0 fat     6409 b- defN 15-Aug-16 19:58 py3traits-1.2.0.dist-info/DESCRIPTION.rst
--rw-rw-rw-  2.0 fat      848 b- defN 15-Aug-16 19:58 py3traits-1.2.0.dist-info/metadata.json
--rw-rw-rw-  2.0 fat        9 b- defN 15-Aug-16 19:58 py3traits-1.2.0.dist-info/top_level.txt
--rw-rw-rw-  2.0 fat      116 b- defN 15-Aug-16 19:58 py3traits-1.2.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat     7129 b- defN 15-Aug-16 19:58 py3traits-1.2.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat     2923 b- defN 15-Aug-16 19:58 py3traits-1.2.0.dist-info/RECORD
-33 files, 98067 bytes uncompressed, 38003 bytes compressed:  61.2%
+Zip file size: 43370 bytes, number of entries: 33
+-rw-r--r--  2.0 unx     1056 b- defN 23-Apr-09 10:22 pytraits/__init__.py
+-rw-r--r--  2.0 unx     1678 b- defN 22-Jun-18 18:40 pytraits/combiner.py
+-rw-r--r--  2.0 unx     2216 b- defN 22-Jun-18 18:40 pytraits/extendable.py
+-rw-r--r--  2.0 unx     3362 b- defN 22-Jun-18 18:40 pytraits/setproperty.py
+-rw-r--r--  2.0 unx     2046 b- defN 22-Jun-18 18:40 pytraits/trait_composer.py
+-rw-r--r--  2.0 unx      209 b- defN 22-Jun-18 18:40 pytraits/core/__init__.py
+-rw-r--r--  2.0 unx      990 b- defN 22-Jun-18 18:40 pytraits/core/base/__init__.py
+-rw-r--r--  2.0 unx     1814 b- defN 22-Jun-18 18:40 pytraits/core/base/inspectors.py
+-rw-r--r--  2.0 unx      835 b- defN 22-Jun-18 18:40 pytraits/core/composing/__init__.py
+-rw-r--r--  2.0 unx     3262 b- defN 22-Jun-18 18:40 pytraits/core/composing/compiler.py
+-rw-r--r--  2.0 unx     5705 b- defN 22-Jun-18 18:40 pytraits/core/composing/composer.py
+-rw-r--r--  2.0 unx     1690 b- defN 22-Jun-18 18:40 pytraits/core/composing/resolutions.py
+-rw-r--r--  2.0 unx     3345 b- defN 22-Jun-18 18:40 pytraits/core/composing/traits.py
+-rw-r--r--  2.0 unx     1750 b- defN 22-Jun-18 18:40 pytraits/core/primitives/__init__.py
+-rw-r--r--  2.0 unx     1530 b- defN 22-Jun-18 18:40 pytraits/core/primitives/class_object.py
+-rw-r--r--  2.0 unx     2861 b- defN 22-Jun-18 18:40 pytraits/core/primitives/instance_object.py
+-rw-r--r--  2.0 unx     1743 b- defN 22-Jun-18 18:40 pytraits/core/primitives/property_object.py
+-rw-r--r--  2.0 unx     3894 b- defN 22-Jun-18 18:40 pytraits/core/primitives/routine_object.py
+-rw-r--r--  2.0 unx     1326 b- defN 22-Jun-18 18:40 pytraits/core/primitives/trait_object.py
+-rw-r--r--  2.0 unx      920 b- defN 22-Jun-18 18:40 pytraits/core/primitives/unidentified_object.py
+-rw-r--r--  2.0 unx      979 b- defN 22-Jun-18 18:40 pytraits/support/__init__.py
+-rw-r--r--  2.0 unx     1819 b- defN 22-Jun-18 18:40 pytraits/support/errors.py
+-rw-r--r--  2.0 unx     5650 b- defN 22-Jun-18 18:40 pytraits/support/factory.py
+-rw-r--r--  2.0 unx     9559 b- defN 22-Jun-18 18:40 pytraits/support/inspector.py
+-rw-r--r--  2.0 unx    11743 b- defN 22-Jun-18 18:40 pytraits/support/magic.py
+-rw-r--r--  2.0 unx     2233 b- defN 22-Jun-18 18:40 pytraits/support/singleton.py
+-rw-r--r--  2.0 unx     4230 b- defN 22-Jun-18 18:40 pytraits/support/utils.py
+-rw-r--r--  2.0 unx       70 b- defN 23-Apr-09 10:23 py3traits-1.2.1.dist-info/AUTHORS.rst
+-rw-r--r--  2.0 unx    10140 b- defN 23-Apr-09 10:23 py3traits-1.2.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7356 b- defN 23-Apr-09 10:23 py3traits-1.2.1.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Apr-09 10:23 py3traits-1.2.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx        9 b- defN 23-Apr-09 10:23 py3traits-1.2.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2878 b- defN 23-Apr-09 10:23 py3traits-1.2.1.dist-info/RECORD
+33 files, 99008 bytes uncompressed, 38720 bytes compressed:  60.9%
```

## zipnote {}

```diff
@@ -1,44 +1,47 @@
+Filename: pytraits/__init__.py
+Comment: 
+
 Filename: pytraits/combiner.py
 Comment: 
 
 Filename: pytraits/extendable.py
 Comment: 
 
 Filename: pytraits/setproperty.py
 Comment: 
 
 Filename: pytraits/trait_composer.py
 Comment: 
 
-Filename: pytraits/__init__.py
+Filename: pytraits/core/__init__.py
 Comment: 
 
-Filename: pytraits/core/__init__.py
+Filename: pytraits/core/base/__init__.py
 Comment: 
 
 Filename: pytraits/core/base/inspectors.py
 Comment: 
 
-Filename: pytraits/core/base/__init__.py
+Filename: pytraits/core/composing/__init__.py
 Comment: 
 
 Filename: pytraits/core/composing/compiler.py
 Comment: 
 
 Filename: pytraits/core/composing/composer.py
 Comment: 
 
 Filename: pytraits/core/composing/resolutions.py
 Comment: 
 
 Filename: pytraits/core/composing/traits.py
 Comment: 
 
-Filename: pytraits/core/composing/__init__.py
+Filename: pytraits/core/primitives/__init__.py
 Comment: 
 
 Filename: pytraits/core/primitives/class_object.py
 Comment: 
 
 Filename: pytraits/core/primitives/instance_object.py
 Comment: 
@@ -51,15 +54,15 @@
 
 Filename: pytraits/core/primitives/trait_object.py
 Comment: 
 
 Filename: pytraits/core/primitives/unidentified_object.py
 Comment: 
 
-Filename: pytraits/core/primitives/__init__.py
+Filename: pytraits/support/__init__.py
 Comment: 
 
 Filename: pytraits/support/errors.py
 Comment: 
 
 Filename: pytraits/support/factory.py
 Comment: 
@@ -72,29 +75,26 @@
 
 Filename: pytraits/support/singleton.py
 Comment: 
 
 Filename: pytraits/support/utils.py
 Comment: 
 
-Filename: pytraits/support/__init__.py
-Comment: 
-
-Filename: py3traits-1.2.0.dist-info/DESCRIPTION.rst
+Filename: py3traits-1.2.1.dist-info/AUTHORS.rst
 Comment: 
 
-Filename: py3traits-1.2.0.dist-info/metadata.json
+Filename: py3traits-1.2.1.dist-info/LICENSE
 Comment: 
 
-Filename: py3traits-1.2.0.dist-info/top_level.txt
+Filename: py3traits-1.2.1.dist-info/METADATA
 Comment: 
 
-Filename: py3traits-1.2.0.dist-info/WHEEL
+Filename: py3traits-1.2.1.dist-info/WHEEL
 Comment: 
 
-Filename: py3traits-1.2.0.dist-info/METADATA
+Filename: py3traits-1.2.1.dist-info/top_level.txt
 Comment: 
 
-Filename: py3traits-1.2.0.dist-info/RECORD
+Filename: py3traits-1.2.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pytraits/combiner.py

 * *Ordering differences only*

```diff
@@ -1,57 +1,57 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.trait_composer import add_traits
-
-
-def combine_class(class_name: str, *traits, **resolved_conflicts):
-    """ This function composes new class out of any number of traits.
-
-    Args:
-        class_name: Name of the new class.
-        traits: Collection of traits, such as functions, classes or instances.
-
-    Keyword Args:
-        name of trait (str): new name
-
-    Example of combining multiple classes to one:
-
-    >>> class One:
-    ...     def first(self): return 1
-    ...
-    >>> class Two:
-    ...     def second(self): return 2
-    ...
-    >>> class Three:
-    ...     def third(self): return 3
-    ...
-    >>> Combination = combine_class("Combination", One, Two, Three)
-    >>> instance = Combination()
-    >>> instance.first(), instance.second(), instance.third()
-    (1, 2, 3)
-    >>> instance.__class__.__name__
-    'Combination'
-    """
-    NewClass = type(class_name, (object,), {})
-    add_traits(NewClass, *traits)
-    return NewClass
-
-
-if __name__ == '__main__':
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.trait_composer import add_traits
+
+
+def combine_class(class_name: str, *traits, **resolved_conflicts):
+    """ This function composes new class out of any number of traits.
+
+    Args:
+        class_name: Name of the new class.
+        traits: Collection of traits, such as functions, classes or instances.
+
+    Keyword Args:
+        name of trait (str): new name
+
+    Example of combining multiple classes to one:
+
+    >>> class One:
+    ...     def first(self): return 1
+    ...
+    >>> class Two:
+    ...     def second(self): return 2
+    ...
+    >>> class Three:
+    ...     def third(self): return 3
+    ...
+    >>> Combination = combine_class("Combination", One, Two, Three)
+    >>> instance = Combination()
+    >>> instance.first(), instance.second(), instance.third()
+    (1, 2, 3)
+    >>> instance.__class__.__name__
+    'Combination'
+    """
+    NewClass = type(class_name, (object,), {})
+    add_traits(NewClass, *traits)
+    return NewClass
+
+
+if __name__ == '__main__':
+    import doctest
+    doctest.testmod()
```

## pytraits/extendable.py

 * *Ordering differences only*

```diff
@@ -1,69 +1,69 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.trait_composer import add_traits
-
-
-def extendable(target):
-    """
-    Decorator that adds function for object to be extended using traits.
-
-    NOTE: The 'add_traits' function this extendable decorator adds contains
-          behavior that differs from usual function behavior. This method
-          alters its behavior depending is the function called on a class
-          or on an instance. If the function is invoked on class, then the
-          class gets updated by the traits, affecting all new instances
-          created from the class. On the other hand, if the function is invoked
-          on an instance, only that instance gets the update, NOT whole class.
-
-          See complete example from:
-          pytraits/examples/extendable_function_class_vs_instance.py
-
-    >>> @extendable
-    ... class ExampleClass:
-    ...     pass
-    ...
-    >>> hasattr(ExampleClass, 'add_traits')
-    True
-
-    >>> class InstanceExample:
-    ...     pass
-    ...
-    >>> instance_example = InstanceExample()
-    >>> _ = extendable(instance_example)
-    >>> hasattr(instance_example, 'add_traits')
-    True
-    """
-    class TypeFunction:
-        def __init__(self):
-            self._target_object = None
-
-        def __call__(self, *args, **kwargs):
-            add_traits(self._target_object, *args, **kwargs)
-
-        def __get__(self, instance, clazz):
-            self._target_object = instance or clazz
-            return self
-
-    target.add_traits = TypeFunction()
-    return target
-
-
-if __name__ == '__main__':
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.trait_composer import add_traits
+
+
+def extendable(target):
+    """
+    Decorator that adds function for object to be extended using traits.
+
+    NOTE: The 'add_traits' function this extendable decorator adds contains
+          behavior that differs from usual function behavior. This method
+          alters its behavior depending is the function called on a class
+          or on an instance. If the function is invoked on class, then the
+          class gets updated by the traits, affecting all new instances
+          created from the class. On the other hand, if the function is invoked
+          on an instance, only that instance gets the update, NOT whole class.
+
+          See complete example from:
+          pytraits/examples/extendable_function_class_vs_instance.py
+
+    >>> @extendable
+    ... class ExampleClass:
+    ...     pass
+    ...
+    >>> hasattr(ExampleClass, 'add_traits')
+    True
+
+    >>> class InstanceExample:
+    ...     pass
+    ...
+    >>> instance_example = InstanceExample()
+    >>> _ = extendable(instance_example)
+    >>> hasattr(instance_example, 'add_traits')
+    True
+    """
+    class TypeFunction:
+        def __init__(self):
+            self._target_object = None
+
+        def __call__(self, *args, **kwargs):
+            add_traits(self._target_object, *args, **kwargs)
+
+        def __get__(self, instance, clazz):
+            self._target_object = instance or clazz
+            return self
+
+    target.add_traits = TypeFunction()
+    return target
+
+
+if __name__ == '__main__':
+    import doctest
+    doctest.testmod()
```

## pytraits/setproperty.py

 * *Ordering differences only*

```diff
@@ -1,99 +1,99 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-import inspect
-
-from pytraits.trait_composer import add_traits
-
-__all__ = ["setproperty"]
-
-
-def setproperty(target, fget=None, fset=None, fdel=None, source=None, name=None):
-    """
-    Convinience function that dynamically creates property to an object.
-    (If you have property created, just use 'add_traits')
-
-    This function has different behavior depending on the target object,
-    whether it is an instance or a class. If target is an instance the
-    property is being set only for that instance. In case the object is
-    a class, the property will be added to it normally to class.
-
-    Args:
-        target (object or type): Target object, which can be any instance or class.
-        fget (str or function): Getter function or its name
-        fset (str or function): Setter function or its name
-        fdel (str or function): Deleter function or its name
-        source (object or type): Source object in case fget, fset and fdel are strings.
-
-    Keyword args:
-        name (str): Name of the property
-        name of fget (str): Name of the property
-
-    Example, where new property is added dynamically into instance:
-
-    >>> class Example:
-    ...     def __init__(self):
-    ...         self.__value = 42
-    ...
-    ...     def set_value(self, new_value):
-    ...         self.__value = new_value
-    ...
-    ...     def value(self):
-    ...         return self.__value
-    ...
-    ...     def del_value(self):
-    ...         self.__value = 42
-    ...
-    >>> instance = Example()
-    >>> setproperty(instance, "value", "set_value", "del_value", name="my_property")
-    >>> instance.my_property
-    42
-    """
-    resolutions = {}
-
-    # If some arguments are left out, skip them from test.
-    args = [arg for arg in (fget, fset, fdel) if arg]
-
-    # There must be at least one argument
-    if not args:
-        raise TypeError("Property needs to have at least one function.")
-
-    # Handle case, when all provided arguments are strings.
-    elif all(isinstance(arg, str) for arg in args):
-        owner = source or target
-        resolutions[fget] = name
-
-        new_property = property(getattr(owner, fget or "", None),
-                                getattr(owner, fset or "", None),
-                                getattr(owner, fdel or "", None))
-
-    # It is also possible to provide functions.
-    elif all(inspect.isroutine(arg) for arg in args):
-        resolutions[fget.__name__] = name
-        new_property = property(fget, fset, fdel)
-
-    # Other conditions are not supported.
-    else:
-        raise TypeError("Unsupported setup for property functions!")
-
-    add_traits(target, new_property, **resolutions)
-
-
-if __name__ == '__main__':
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+import inspect
+
+from pytraits.trait_composer import add_traits
+
+__all__ = ["setproperty"]
+
+
+def setproperty(target, fget=None, fset=None, fdel=None, source=None, name=None):
+    """
+    Convinience function that dynamically creates property to an object.
+    (If you have property created, just use 'add_traits')
+
+    This function has different behavior depending on the target object,
+    whether it is an instance or a class. If target is an instance the
+    property is being set only for that instance. In case the object is
+    a class, the property will be added to it normally to class.
+
+    Args:
+        target (object or type): Target object, which can be any instance or class.
+        fget (str or function): Getter function or its name
+        fset (str or function): Setter function or its name
+        fdel (str or function): Deleter function or its name
+        source (object or type): Source object in case fget, fset and fdel are strings.
+
+    Keyword args:
+        name (str): Name of the property
+        name of fget (str): Name of the property
+
+    Example, where new property is added dynamically into instance:
+
+    >>> class Example:
+    ...     def __init__(self):
+    ...         self.__value = 42
+    ...
+    ...     def set_value(self, new_value):
+    ...         self.__value = new_value
+    ...
+    ...     def value(self):
+    ...         return self.__value
+    ...
+    ...     def del_value(self):
+    ...         self.__value = 42
+    ...
+    >>> instance = Example()
+    >>> setproperty(instance, "value", "set_value", "del_value", name="my_property")
+    >>> instance.my_property
+    42
+    """
+    resolutions = {}
+
+    # If some arguments are left out, skip them from test.
+    args = [arg for arg in (fget, fset, fdel) if arg]
+
+    # There must be at least one argument
+    if not args:
+        raise TypeError("Property needs to have at least one function.")
+
+    # Handle case, when all provided arguments are strings.
+    elif all(isinstance(arg, str) for arg in args):
+        owner = source or target
+        resolutions[fget] = name
+
+        new_property = property(getattr(owner, fget or "", None),
+                                getattr(owner, fset or "", None),
+                                getattr(owner, fdel or "", None))
+
+    # It is also possible to provide functions.
+    elif all(inspect.isroutine(arg) for arg in args):
+        resolutions[fget.__name__] = name
+        new_property = property(fget, fset, fdel)
+
+    # Other conditions are not supported.
+    else:
+        raise TypeError("Unsupported setup for property functions!")
+
+    add_traits(target, new_property, **resolutions)
+
+
+if __name__ == '__main__':
+    import doctest
+    doctest.testmod()
```

## pytraits/trait_composer.py

 * *Ordering differences only*

```diff
@@ -1,65 +1,65 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.core import TraitFactory
-from pytraits.support import type_converted
-
-
-TraitTarget = TraitFactory["TraitTargetInspector"]
-Traits = TraitFactory["Traits"]
-
-
-@type_converted
-def add_traits(target: TraitTarget, *traits, **resolutions):
-    """ Bind new traits to given object.
-
-    Args:
-        target: Object of any type that is going to be extended with traits
-        traits: Tuple of traits as object and strings or callables or functions.
-        resolutions: dictionary of conflict resolutions to solve situations
-                     where multiple methods or properties of same name are
-                     encountered in traits.
-
-    >>> class ExampleClass:
-    ...    def example_method(self):
-    ...        return None
-    ...
-    >>> class ExampleTrait:
-    ...    def other_method(self):
-    ...        return 42
-    ...
-    >>> add_traits(ExampleClass, ExampleTrait)
-    >>> ExampleClass().other_method()
-    42
-    """
-    # Return immediately, if no traits provided.
-    if not len(traits):
-        return
-
-    # Just prepare object to start the work and get done with it.
-    traits = Traits(traits)
-
-    # This call puts all gears moving. Each trait in turn is being added
-    # to target object. Resolutions are used to solve any conflicts along
-    # the way.
-    traits.compose(target, resolutions)
-
-
-if __name__ == '__main__':
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.core import TraitFactory
+from pytraits.support import type_converted
+
+
+TraitTarget = TraitFactory["TraitTargetInspector"]
+Traits = TraitFactory["Traits"]
+
+
+@type_converted
+def add_traits(target: TraitTarget, *traits, **resolutions):
+    """ Bind new traits to given object.
+
+    Args:
+        target: Object of any type that is going to be extended with traits
+        traits: Tuple of traits as object and strings or callables or functions.
+        resolutions: dictionary of conflict resolutions to solve situations
+                     where multiple methods or properties of same name are
+                     encountered in traits.
+
+    >>> class ExampleClass:
+    ...    def example_method(self):
+    ...        return None
+    ...
+    >>> class ExampleTrait:
+    ...    def other_method(self):
+    ...        return 42
+    ...
+    >>> add_traits(ExampleClass, ExampleTrait)
+    >>> ExampleClass().other_method()
+    42
+    """
+    # Return immediately, if no traits provided.
+    if not len(traits):
+        return
+
+    # Just prepare object to start the work and get done with it.
+    traits = Traits(traits)
+
+    # This call puts all gears moving. Each trait in turn is being added
+    # to target object. Resolutions are used to solve any conflicts along
+    # the way.
+    traits.compose(target, resolutions)
+
+
+if __name__ == '__main__':
+    import doctest
+    doctest.testmod()
```

## pytraits/__init__.py

```diff
@@ -1,27 +1,27 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.support import Singleton, Factory, type_safe, type_converted
-from pytraits.combiner import combine_class
-from pytraits.extendable import extendable
-from pytraits.setproperty import setproperty
-from pytraits.trait_composer import add_traits
-
-__version__ = "1.2.0"
-__all__ = ["Singleton", "Factory", "combine_class", "extendable", "add_traits",
-           "type_safe", "type_converted", "setproperty"]
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.support import Singleton, Factory, type_safe, type_converted
+from pytraits.combiner import combine_class
+from pytraits.extendable import extendable
+from pytraits.setproperty import setproperty
+from pytraits.trait_composer import add_traits
+
+__version__ = "1.2.1"
+__all__ = ["Singleton", "Factory", "combine_class", "extendable", "add_traits",
+           "type_safe", "type_converted", "setproperty"]
```

## pytraits/core/__init__.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-
-from .base import TraitFactory
-from .primitives.trait_object import TraitObject
-import pytraits.core.composing  # NOQA
-
-__all__ = ["TraitObject", "TraitFactory"]
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+
+from .base import TraitFactory
+from .primitives.trait_object import TraitObject
+import pytraits.core.composing  # NOQA
+
+__all__ = ["TraitObject", "TraitFactory"]
```

## pytraits/core/base/inspectors.py

 * *Ordering differences only*

```diff
@@ -1,59 +1,59 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.support import Inspector, Singleton
-
-
-class TraitInspector(metaclass=Singleton):
-    """ Trait specific implementation of Inspector.
-
-    This class is extension to general purpose Inspector. While original
-    inspector gives string as a result of inspection, this class provides
-    whole class (a.k.a Primitive) to caller. These primitives then provide
-    special functionality for given object type.
-
-    This class acts also as a singleton.
-    """
-    def __init__(self):
-        self.__inspector = Inspector()
-
-    def __call__(self, object):
-        return self.__inspector.inspect(object)
-
-    @classmethod
-    def add_hook(cls, name, hook):
-        cls().__inspector.add_hook(name, hook)
-
-    @classmethod
-    def add_default_hook(cls, hook):
-        cls().__inspector.add_default_hook(hook)
-
-
-class TraitTargetInspector(TraitInspector):
-    """ Inspector used to identify target objects for trait composition. """
-    TYPE = "target"
-
-
-class TraitSourceInspector(TraitInspector):
-    """ Inspector used to identify source objects for trait composition """
-    TYPE = "source"
-
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.support import Inspector, Singleton
+
+
+class TraitInspector(metaclass=Singleton):
+    """ Trait specific implementation of Inspector.
+
+    This class is extension to general purpose Inspector. While original
+    inspector gives string as a result of inspection, this class provides
+    whole class (a.k.a Primitive) to caller. These primitives then provide
+    special functionality for given object type.
+
+    This class acts also as a singleton.
+    """
+    def __init__(self):
+        self.__inspector = Inspector()
+
+    def __call__(self, object):
+        return self.__inspector.inspect(object)
+
+    @classmethod
+    def add_hook(cls, name, hook):
+        cls().__inspector.add_hook(name, hook)
+
+    @classmethod
+    def add_default_hook(cls, hook):
+        cls().__inspector.add_default_hook(hook)
+
+
+class TraitTargetInspector(TraitInspector):
+    """ Inspector used to identify target objects for trait composition. """
+    TYPE = "target"
+
+
+class TraitSourceInspector(TraitInspector):
+    """ Inspector used to identify source objects for trait composition """
+    TYPE = "source"
+
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## pytraits/core/base/__init__.py

 * *Ordering differences only*

```diff
@@ -1,30 +1,30 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.support import Factory
-from .inspectors import TraitSourceInspector, TraitTargetInspector
-
-
-class TraitFactory(Factory):
-    """ Factory for core trait objects. """
-
-# TODO: Don't leave this permanent
-TraitFactory(override_duplicates=True)
-TraitFactory.register(TraitSourceInspector, TraitTargetInspector)
-
-__all__ = ["TraitFactory"]
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.support import Factory
+from .inspectors import TraitSourceInspector, TraitTargetInspector
+
+
+class TraitFactory(Factory):
+    """ Factory for core trait objects. """
+
+# TODO: Don't leave this permanent
+TraitFactory(override_duplicates=True)
+TraitFactory.register(TraitSourceInspector, TraitTargetInspector)
+
+__all__ = ["TraitFactory"]
```

## pytraits/core/composing/compiler.py

```diff
@@ -1,85 +1,88 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-import types
-import collections
-
-from pytraits.support import is_sysname
-from pytraits.core import TraitFactory
-
-
-@TraitFactory.register
-class Compiler:
-    """
-    Compiler to transfer the function to other class or instance.
-
-    This class works as a heart of the whole system. To make function to be fully
-    part of other class or instance, it needs to be recompiled on top of target
-    object, as if it was written there in the first place. This is because internals
-    of the function are read-only and we need to change them in order to access
-    private attributes.
-    """
-    def _clone_function(self, function):
-        trait = collections.OrderedDict()
-
-        trait["co_argcount"] = function.__code__.co_argcount
-        trait["co_kwonlyargcount"] = function.__code__.co_kwonlyargcount
-        trait["co_nlocals"] = function.__code__.co_nlocals
-        trait["co_stacksize"] = function.__code__.co_stacksize
-        trait["co_flags"] = function.__code__.co_flags
-        trait["co_code"] = function.__code__.co_code
-        trait["co_consts"] = function.__code__.co_consts
-        trait["co_names"] = function.__code__.co_names
-        trait["co_varnames"] = function.__code__.co_varnames
-        trait["co_filename"] = function.__code__.co_filename
-        trait["co_name"] = function.__code__.co_name
-        trait["co_firstlineno"] = function.__code__.co_firstlineno
-        trait["co_lnotab"] = function.__code__.co_lnotab
-
-        return trait
-
-    def _transfer_names(self, trait, clazz):
-        items = []
-        for name in trait["co_names"]:
-            if "__" not in name or is_sysname(name):
-                items.append(name)
-            else:
-                items.append("_%s%s" % (clazz.__name__, name[name.index('__'):]))
-        trait["co_names"] = tuple(items)
-
-    def _compile_trait(self, trait, globs):
-        return types.FunctionType(types.CodeType(*trait.values()), globs)
-
-    def recompile(self, function, target, name: str=""):
-        """
-        Recompile function on target object.
-
-        @param function: Function to be recompiled
-        @param target: Target class or instance
-        @param {str} name: New name for the target
-        """
-        trait = self._clone_function(function)
-        self._transfer_names(trait, target)
-        trait["co_name"] = name or trait["co_name"].strip('<>')
-
-        return self._compile_trait(trait, function.__globals__)
-
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+import types
+import collections
+import sys
+
+from pytraits.support import is_sysname
+from pytraits.core import TraitFactory
+
+
+@TraitFactory.register
+class Compiler:
+    """
+    Compiler to transfer the function to other class or instance.
+
+    This class works as a heart of the whole system. To make function to be fully
+    part of other class or instance, it needs to be recompiled on top of target
+    object, as if it was written there in the first place. This is because internals
+    of the function are read-only and we need to change them in order to access
+    private attributes.
+    """
+    def _clone_function(self, function):
+        trait = collections.OrderedDict()
+
+        trait["co_argcount"] = function.__code__.co_argcount
+        trait["co_kwonlyargcount"] = function.__code__.co_kwonlyargcount
+        if sys.version_info[:2] >= (3, 8) :
+          trait["co_posonlyargcount"] = function.__code__.co_posonlyargcount
+        trait["co_nlocals"] = function.__code__.co_nlocals
+        trait["co_stacksize"] = function.__code__.co_stacksize
+        trait["co_flags"] = function.__code__.co_flags
+        trait["co_code"] = function.__code__.co_code
+        trait["co_consts"] = function.__code__.co_consts
+        trait["co_names"] = function.__code__.co_names
+        trait["co_varnames"] = function.__code__.co_varnames
+        trait["co_filename"] = function.__code__.co_filename
+        trait["co_name"] = function.__code__.co_name
+        trait["co_firstlineno"] = function.__code__.co_firstlineno
+        trait["co_lnotab"] = function.__code__.co_lnotab
+
+        return trait
+
+    def _transfer_names(self, trait, clazz):
+        items = []
+        for name in trait["co_names"]:
+            if "__" not in name or is_sysname(name):
+                items.append(name)
+            else:
+                items.append("_%s%s" % (clazz.__name__, name[name.index('__'):]))
+        trait["co_names"] = tuple(items)
+
+    def _compile_trait(self, trait, globs):
+        return types.FunctionType(types.CodeType(*trait.values()), globs)
+
+    def recompile(self, function, target, name: str=""):
+        """
+        Recompile function on target object.
+
+        @param function: Function to be recompiled
+        @param target: Target class or instance
+        @param {str} name: New name for the target
+        """
+        trait = self._clone_function(function)
+        self._transfer_names(trait, target)
+        trait["co_name"] = name or trait["co_name"].strip('<>')
+
+        return self._compile_trait(trait, function.__globals__)
+
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## pytraits/core/composing/composer.py

 * *Ordering differences only*

```diff
@@ -1,139 +1,139 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.support import type_safe
-from pytraits.core import TraitFactory, TraitObject
-
-
-@TraitFactory.register
-class Composer:
-    """ Factory object for composers.
-
-    This factory object is called for each pair of object that is being composed
-    together. Composer object is created for identified and supported pairs of
-    target and source objects. Some combinations can require special behavior
-    which these composer objects need to address.
-
-    Composing itself is a process, where source object is first recompiled
-    and then bound against the new target. Compiling is required to alter the
-    content of code object to match target object and binding is required to
-    be able to call the function.
-    """
-    # Dictionary of registered composers. Each composer is identified by
-    # two strings (target type names) as a key and all composers are added here
-    # by ComposerMeta metaclass.
-    __COMPOSERS = dict()
-
-    @classmethod
-    def register(cls, key, composer):
-        """ Stores composer with given key for the future use. """
-        cls.__COMPOSERS[key] = composer
-
-    @type_safe
-    def __call__(self, target: TraitObject, source: TraitObject):
-        """ Factory method that selects correct composer for target and source. """
-        # Each TraitObject has a string representation that can be used to
-        # select correct composer.
-        joined = str(target), str(source)
-        try:
-            return self.__COMPOSERS[joined](target, source)
-        except KeyError:
-            msg = "{target} '{targetqname}' and {source} '{sourceqname}' is not supported combination!"
-            msg = msg.format(target=str(target),
-                             targetqname=target.qualname,
-                             source=str(source),
-                             sourceqname=source.qualname)
-            raise TypeError(msg)
-
-
-class ComposerMeta(type):
-    """ Automatically registers all composers to Composer factory class. """
-    def __init__(cls, name, bases, attrs):
-        """ Handles registering of classes to Composer factory class.
-
-        This function is called when initializing the class object. Any class
-        that is identified as a composer (=has defined CAN_COMPOSE attribute)
-        is registered to factory.
-        """
-        for support in getattr(cls, "CAN_COMPOSE", ()):
-            Composer.register(support, cls)
-
-    @type_safe
-    def __call__(cls, target: TraitObject, source: TraitObject):
-        """ Initializes class instance.
-
-        This function is roughly equivalent to class.__init__. Here we
-        initialize the composer object.
-        """
-        instance = super().__call__()
-        instance.target = target
-        instance.source = source
-        return instance
-
-
-class BasicComposer(metaclass=ComposerMeta):
-    """ Basic composer for simple types.
-
-    This class handles composition of most of the target - source pairs.
-    """
-    CAN_COMPOSE = [('class', 'method'), ('instance', 'method'),
-                   ('class', 'classmethod'), ('instance', 'classmethod'),
-                   ('class', 'staticmethod'), ('instance', 'staticmethod'),
-                   ('class', 'builtin'), ('instance', 'builtin'),
-                   ('class', 'property')]
-
-    def compose(self, resolutions):
-        """ Composes trait to target object.
-
-        General flow of composition is:
-            - Resolve the name of the trait in target object.
-            - Compile trait against the target (as if it was written to it.)
-            - Bind the compiled trait to target.
-        """
-        name = resolutions.resolve(self.source.name)
-        compiled = self.source.recompile(self.target, name)
-        bound = self.source.rebind(self.target, compiled)
-        self.target[name] = bound
-
-
-class Property2Instance(metaclass=ComposerMeta):
-    """ Special handling for composing properties to instances. """
-    CAN_COMPOSE = [('instance', 'property')]
-
-    def compose(self, resolutions):
-        """ Composes property trait to instance target.
-
-        Composing properties to instances is bit trickier business, since
-        properties are descriptors by their nature and they work only on class
-        level. If we assign the property to instance's dictionary (instance.__dict__),
-        it won't work at all. If we assign the property to instance's class'
-        dictionary (instance.__class__.__dict__), it will work, but the property
-        will go to any other instance of that class too. That's why, we create
-        a clone of the class and set it to instance.
-        """
-        # Modify target instance so that changing its class content won't
-        # affect other classes.
-        self.target.forge()
-
-        # Resolve the name and recompile
-        name = resolutions.resolve(self.source.name)
-        compiled = self.source.recompile(self.target, name)
-
-        # Assing property to instance's class.
-        # TODO: Figure out pretty way to do this by calling target's function.
-        setattr(self.target.compile_target, name, compiled)
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.support import type_safe
+from pytraits.core import TraitFactory, TraitObject
+
+
+@TraitFactory.register
+class Composer:
+    """ Factory object for composers.
+
+    This factory object is called for each pair of object that is being composed
+    together. Composer object is created for identified and supported pairs of
+    target and source objects. Some combinations can require special behavior
+    which these composer objects need to address.
+
+    Composing itself is a process, where source object is first recompiled
+    and then bound against the new target. Compiling is required to alter the
+    content of code object to match target object and binding is required to
+    be able to call the function.
+    """
+    # Dictionary of registered composers. Each composer is identified by
+    # two strings (target type names) as a key and all composers are added here
+    # by ComposerMeta metaclass.
+    __COMPOSERS = dict()
+
+    @classmethod
+    def register(cls, key, composer):
+        """ Stores composer with given key for the future use. """
+        cls.__COMPOSERS[key] = composer
+
+    @type_safe
+    def __call__(self, target: TraitObject, source: TraitObject):
+        """ Factory method that selects correct composer for target and source. """
+        # Each TraitObject has a string representation that can be used to
+        # select correct composer.
+        joined = str(target), str(source)
+        try:
+            return self.__COMPOSERS[joined](target, source)
+        except KeyError:
+            msg = "{target} '{targetqname}' and {source} '{sourceqname}' is not supported combination!"
+            msg = msg.format(target=str(target),
+                             targetqname=target.qualname,
+                             source=str(source),
+                             sourceqname=source.qualname)
+            raise TypeError(msg)
+
+
+class ComposerMeta(type):
+    """ Automatically registers all composers to Composer factory class. """
+    def __init__(cls, name, bases, attrs):
+        """ Handles registering of classes to Composer factory class.
+
+        This function is called when initializing the class object. Any class
+        that is identified as a composer (=has defined CAN_COMPOSE attribute)
+        is registered to factory.
+        """
+        for support in getattr(cls, "CAN_COMPOSE", ()):
+            Composer.register(support, cls)
+
+    @type_safe
+    def __call__(cls, target: TraitObject, source: TraitObject):
+        """ Initializes class instance.
+
+        This function is roughly equivalent to class.__init__. Here we
+        initialize the composer object.
+        """
+        instance = super().__call__()
+        instance.target = target
+        instance.source = source
+        return instance
+
+
+class BasicComposer(metaclass=ComposerMeta):
+    """ Basic composer for simple types.
+
+    This class handles composition of most of the target - source pairs.
+    """
+    CAN_COMPOSE = [('class', 'method'), ('instance', 'method'),
+                   ('class', 'classmethod'), ('instance', 'classmethod'),
+                   ('class', 'staticmethod'), ('instance', 'staticmethod'),
+                   ('class', 'builtin'), ('instance', 'builtin'),
+                   ('class', 'property')]
+
+    def compose(self, resolutions):
+        """ Composes trait to target object.
+
+        General flow of composition is:
+            - Resolve the name of the trait in target object.
+            - Compile trait against the target (as if it was written to it.)
+            - Bind the compiled trait to target.
+        """
+        name = resolutions.resolve(self.source.name)
+        compiled = self.source.recompile(self.target, name)
+        bound = self.source.rebind(self.target, compiled)
+        self.target[name] = bound
+
+
+class Property2Instance(metaclass=ComposerMeta):
+    """ Special handling for composing properties to instances. """
+    CAN_COMPOSE = [('instance', 'property')]
+
+    def compose(self, resolutions):
+        """ Composes property trait to instance target.
+
+        Composing properties to instances is bit trickier business, since
+        properties are descriptors by their nature and they work only on class
+        level. If we assign the property to instance's dictionary (instance.__dict__),
+        it won't work at all. If we assign the property to instance's class'
+        dictionary (instance.__class__.__dict__), it will work, but the property
+        will go to any other instance of that class too. That's why, we create
+        a clone of the class and set it to instance.
+        """
+        # Modify target instance so that changing its class content won't
+        # affect other classes.
+        self.target.forge()
+
+        # Resolve the name and recompile
+        name = resolutions.resolve(self.source.name)
+        compiled = self.source.recompile(self.target, name)
+
+        # Assing property to instance's class.
+        # TODO: Figure out pretty way to do this by calling target's function.
+        setattr(self.target.compile_target, name, compiled)
```

## pytraits/core/composing/resolutions.py

 * *Ordering differences only*

```diff
@@ -1,51 +1,51 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.core import TraitFactory
-
-
-@TraitFactory.register
-class Resolutions:
-    """ Container of resolutions for possible conflicts during composition.
-
-    During composition process, function or property names can collide and
-    every situation should be handled by user at the same time the traits
-    are composed. That will guarantee that class or instance will behave
-    as expected in every situation.
-    """
-    def __init__(self, resolutions):
-        self.__resolutions = resolutions
-
-    def resolve(self, name):
-        """ Resolves name that shall be used for trait being composed.
-
-        NOTE: Currently it is possible to rename traits but collisions are
-              not checked.
-
-        Returns:
-            (string) name of the trait
-            (NoneType) nothing is returned in case trait should be ignored
-
-        Raises:
-            Error if there is a conflict but no resolution.
-        """
-        return self.__resolutions.get(name, name)
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.core import TraitFactory
+
+
+@TraitFactory.register
+class Resolutions:
+    """ Container of resolutions for possible conflicts during composition.
+
+    During composition process, function or property names can collide and
+    every situation should be handled by user at the same time the traits
+    are composed. That will guarantee that class or instance will behave
+    as expected in every situation.
+    """
+    def __init__(self, resolutions):
+        self.__resolutions = resolutions
+
+    def resolve(self, name):
+        """ Resolves name that shall be used for trait being composed.
+
+        NOTE: Currently it is possible to rename traits but collisions are
+              not checked.
+
+        Returns:
+            (string) name of the trait
+            (NoneType) nothing is returned in case trait should be ignored
+
+        Raises:
+            Error if there is a conflict but no resolution.
+        """
+        return self.__resolutions.get(name, name)
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## pytraits/core/composing/traits.py

 * *Ordering differences only*

```diff
@@ -1,94 +1,94 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-import inspect
-
-from pytraits.support import flatten, type_converted
-from pytraits.support.errors import (FirstTraitArgumentError,
-                                     TraitArgumentTypeError)
-from pytraits.core import TraitFactory
-
-TraitSource = TraitFactory["TraitSourceInspector"]
-Resolutions = TraitFactory["Resolutions"]
-
-
-@TraitFactory.register
-class Traits:
-    """ This class encapsulates handling of multiple traits. """
-    def __init__(self, traits):
-        self.__traits = traits
-
-    @classmethod
-    def create(cls, traits):
-        instance = cls(traits)
-
-        # In case object and strings are given, we need to do some extra work
-        # to get desired traits out.
-        if instance.needs_preprocessing():
-            instance.preprocess()
-        return instance
-
-    def needs_preprocessing(self):
-        """ Identifies need to resolve attributes for string arguments within trait source.
-
-        In order to support following syntax:
-            add_traits(Target, Source, "all", "its", "required", "attributes")
-        we need to turn those strings to objects. This function is to used to
-        identify that need.
-        """
-        # Calculate number of string arguments so that we can give bit more
-        # detailed error messages in case of some weird combinations are found.
-        string_arg_count = 0
-        for arg in self.__traits:
-            if isinstance(arg, str):
-                string_arg_count += 1
-
-        # No string arguments means that all of the traits are objects, who
-        # can be composed directly.
-        if not string_arg_count:
-            return False
-
-        # First trait argument must be an object (instance or class), otherwise
-        # none of this makes any sense.
-        if isinstance(self.__traits[0], str) or inspect.isroutine(self.__traits[0]):
-            raise FirstTraitArgumentError()
-
-        # In case string arguments are provided, all of them have to be strings.
-        if len(self.__traits[1:]) != string_arg_count:
-            raise TraitArgumentTypeError()
-
-        return True
-
-    def preprocess(self):
-        obj = self.__traits[0]
-        names = self.__traits[1:]
-        self.__traits = [getattr(obj, name) for name in names]
-
-    def __iter__(self):
-        """ Walk through each given trait.
-
-        Any class source is walked through for its contents.
-        """
-        for trait in flatten(map(TraitSource, self.__traits)):
-            yield trait
-
-    @type_converted
-    def compose(self, target, resolutions: Resolutions):
-        """ Compose trait sources to target using composer. """
-        for source in self:
-            TraitFactory["Composer"](target, source).compose(resolutions)
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+import inspect
+
+from pytraits.support import flatten, type_converted
+from pytraits.support.errors import (FirstTraitArgumentError,
+                                     TraitArgumentTypeError)
+from pytraits.core import TraitFactory
+
+TraitSource = TraitFactory["TraitSourceInspector"]
+Resolutions = TraitFactory["Resolutions"]
+
+
+@TraitFactory.register
+class Traits:
+    """ This class encapsulates handling of multiple traits. """
+    def __init__(self, traits):
+        self.__traits = traits
+
+    @classmethod
+    def create(cls, traits):
+        instance = cls(traits)
+
+        # In case object and strings are given, we need to do some extra work
+        # to get desired traits out.
+        if instance.needs_preprocessing():
+            instance.preprocess()
+        return instance
+
+    def needs_preprocessing(self):
+        """ Identifies need to resolve attributes for string arguments within trait source.
+
+        In order to support following syntax:
+            add_traits(Target, Source, "all", "its", "required", "attributes")
+        we need to turn those strings to objects. This function is to used to
+        identify that need.
+        """
+        # Calculate number of string arguments so that we can give bit more
+        # detailed error messages in case of some weird combinations are found.
+        string_arg_count = 0
+        for arg in self.__traits:
+            if isinstance(arg, str):
+                string_arg_count += 1
+
+        # No string arguments means that all of the traits are objects, who
+        # can be composed directly.
+        if not string_arg_count:
+            return False
+
+        # First trait argument must be an object (instance or class), otherwise
+        # none of this makes any sense.
+        if isinstance(self.__traits[0], str) or inspect.isroutine(self.__traits[0]):
+            raise FirstTraitArgumentError()
+
+        # In case string arguments are provided, all of them have to be strings.
+        if len(self.__traits[1:]) != string_arg_count:
+            raise TraitArgumentTypeError()
+
+        return True
+
+    def preprocess(self):
+        obj = self.__traits[0]
+        names = self.__traits[1:]
+        self.__traits = [getattr(obj, name) for name in names]
+
+    def __iter__(self):
+        """ Walk through each given trait.
+
+        Any class source is walked through for its contents.
+        """
+        for trait in flatten(map(TraitSource, self.__traits)):
+            yield trait
+
+    @type_converted
+    def compose(self, target, resolutions: Resolutions):
+        """ Compose trait sources to target using composer. """
+        for source in self:
+            TraitFactory["Composer"](target, source).compose(resolutions)
```

## pytraits/core/composing/__init__.py

 * *Ordering differences only*

```diff
@@ -1,22 +1,22 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-import pytraits.core.composing.compiler  # NOQA
-import pytraits.core.composing.resolutions  # NOQA
-import pytraits.core.composing.traits  # NOQA
-import pytraits.core.composing.composer  # NOQA
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+import pytraits.core.composing.compiler  # NOQA
+import pytraits.core.composing.resolutions  # NOQA
+import pytraits.core.composing.traits  # NOQA
+import pytraits.core.composing.composer  # NOQA
```

## pytraits/core/primitives/class_object.py

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-
-from pytraits.support import is_sysname
-from .trait_object import TraitObject
-from ..base import TraitFactory
-
-
-class ClassObject(TraitObject):
-    INSPECTORS = ('source', 'target')
-
-    def __iter__(self):
-        """ Yields each element in the class. """
-        for name, object in self.items():
-            sub = TraitFactory["TraitSourceInspector"](object)
-            if sub:
-                yield sub
-
-    def __dir__(self):
-        return [i[0] for i in self.items()]
-
-    def __getitem__(self, key):
-        return self._object.__dict__[key]
-
-    def __setitem__(self, key, value):
-        setattr(self._object, key, value)
-
-    def items(self):
-        return ((k, v) for (k, v) in self._object.__dict__.items() if not is_sysname(k))
-
-    @property
-    def compile_target(self):
-        return self._object
-
-    @property
-    def bind_target(self):
-        return self._object
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+
+from pytraits.support import is_sysname
+from .trait_object import TraitObject
+from ..base import TraitFactory
+
+
+class ClassObject(TraitObject):
+    INSPECTORS = ('source', 'target')
+
+    def __iter__(self):
+        """ Yields each element in the class. """
+        for name, object in self.items():
+            sub = TraitFactory["TraitSourceInspector"](object)
+            if sub:
+                yield sub
+
+    def __dir__(self):
+        return [i[0] for i in self.items()]
+
+    def __getitem__(self, key):
+        return self._object.__dict__[key]
+
+    def __setitem__(self, key, value):
+        setattr(self._object, key, value)
+
+    def items(self):
+        return ((k, v) for (k, v) in self._object.__dict__.items() if not is_sysname(k))
+
+    @property
+    def compile_target(self):
+        return self._object
+
+    @property
+    def bind_target(self):
+        return self._object
```

## pytraits/core/primitives/instance_object.py

 * *Ordering differences only*

```diff
@@ -1,81 +1,81 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.support import is_sysname
-from .trait_object import TraitObject
-from ..base import TraitFactory
-
-
-class InstanceObject(TraitObject):
-    INSPECTORS = ('source', 'target')
-
-    def __iter__(self):
-        """ Yields each element in the class. """
-        for name, object in self.items():
-            sub = TraitFactory["TraitSourceInspector"](object)
-            if sub:
-                yield sub
-
-    def __dir__(self):
-        return [i[0] for i in self.items()]
-
-    def __getitem__(self, name):
-        try:
-            return self._object.__class__.__dict__[name]
-        except KeyError:
-            return self._object.__dict__[name]
-
-    def __setitem__(self, key, value):
-        self._object.__dict__[key] = value
-
-    @property
-    def compile_target(self):
-        return self._object.__class__
-
-    @property
-    def bind_target(self):
-        return self._object
-
-    def items(self):
-        items = dict()
-        items.update(self._object.__class__.__dict__)
-        items.update(self._object.__dict__)  # Makes sure that instance values override class values.
-        return ((k, v) for (k, v) in items.items() if not is_sysname(k))
-
-    def forge(self):
-        """ Modifies instance's class to be unique.
-
-        This method creates a clone of instance's class and replaces the
-        original class with the clone. By doing this, it allows modifying
-        instance in a manner that no changes are reflected to other instances
-        of the same class.
-
-        This is mainly needed to make properties and other descriptors work
-        so that they can be instance specific. They normally work only on classes
-
-        """
-        # In case the object's class is already forged, no need to do it again.
-        if not hasattr(self._object, '__instance_forged'):
-            # Retrieve the class of the object and create new class inherited
-            # from it. It can be used on this instance again.
-            original_class = self._object.__class__
-            new_class = type(original_class.__name__, (original_class, ), {})
-            new_class.__instance_forged = True
-
-            # Replace the class with forged class.
-            self._object.__class__ = new_class
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.support import is_sysname
+from .trait_object import TraitObject
+from ..base import TraitFactory
+
+
+class InstanceObject(TraitObject):
+    INSPECTORS = ('source', 'target')
+
+    def __iter__(self):
+        """ Yields each element in the class. """
+        for name, object in self.items():
+            sub = TraitFactory["TraitSourceInspector"](object)
+            if sub:
+                yield sub
+
+    def __dir__(self):
+        return [i[0] for i in self.items()]
+
+    def __getitem__(self, name):
+        try:
+            return self._object.__class__.__dict__[name]
+        except KeyError:
+            return self._object.__dict__[name]
+
+    def __setitem__(self, key, value):
+        self._object.__dict__[key] = value
+
+    @property
+    def compile_target(self):
+        return self._object.__class__
+
+    @property
+    def bind_target(self):
+        return self._object
+
+    def items(self):
+        items = dict()
+        items.update(self._object.__class__.__dict__)
+        items.update(self._object.__dict__)  # Makes sure that instance values override class values.
+        return ((k, v) for (k, v) in items.items() if not is_sysname(k))
+
+    def forge(self):
+        """ Modifies instance's class to be unique.
+
+        This method creates a clone of instance's class and replaces the
+        original class with the clone. By doing this, it allows modifying
+        instance in a manner that no changes are reflected to other instances
+        of the same class.
+
+        This is mainly needed to make properties and other descriptors work
+        so that they can be instance specific. They normally work only on classes
+
+        """
+        # In case the object's class is already forged, no need to do it again.
+        if not hasattr(self._object, '__instance_forged'):
+            # Retrieve the class of the object and create new class inherited
+            # from it. It can be used on this instance again.
+            original_class = self._object.__class__
+            new_class = type(original_class.__name__, (original_class, ), {})
+            new_class.__instance_forged = True
+
+            # Replace the class with forged class.
+            self._object.__class__ = new_class
```

## pytraits/core/primitives/property_object.py

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from .trait_object import TraitObject
-
-
-class PropertyObject(TraitObject):
-    INSPECTORS = ('source',)
-
-    def __init__(self, property, name=None):
-        self.__property = property
-        self.__name = name
-        self.__compiler = self.FACTORY["Compiler"]()
-        self.__inspector = self.FACTORY["TraitSourceInspector"]
-
-    def get_func(self, func_name):
-        func = getattr(self.__property, func_name, None)
-        if func:
-            return self.__inspector(func)
-
-    @property
-    def name(self):
-        return self.__name or self.get_func('fget').name
-
-    def __recompile_func(self, func_name, target, new_name):
-        func = self.get_func(func_name)
-        if func:
-            return func.recompile(target, new_name)
-
-    def recompile(self, target, name):
-        getter = self.__recompile_func('fget', target, name)
-        setter = self.__recompile_func('fset', target, name)
-        deleter = self.__recompile_func('fdel', target, name)
-
-        return property(getter, setter, deleter)
-
-    def rebind(self, target, compiled_property):
-        return compiled_property
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from .trait_object import TraitObject
+
+
+class PropertyObject(TraitObject):
+    INSPECTORS = ('source',)
+
+    def __init__(self, property, name=None):
+        self.__property = property
+        self.__name = name
+        self.__compiler = self.FACTORY["Compiler"]()
+        self.__inspector = self.FACTORY["TraitSourceInspector"]
+
+    def get_func(self, func_name):
+        func = getattr(self.__property, func_name, None)
+        if func:
+            return self.__inspector(func)
+
+    @property
+    def name(self):
+        return self.__name or self.get_func('fget').name
+
+    def __recompile_func(self, func_name, target, new_name):
+        func = self.get_func(func_name)
+        if func:
+            return func.recompile(target, new_name)
+
+    def recompile(self, target, name):
+        getter = self.__recompile_func('fget', target, name)
+        setter = self.__recompile_func('fset', target, name)
+        deleter = self.__recompile_func('fdel', target, name)
+
+        return property(getter, setter, deleter)
+
+    def rebind(self, target, compiled_property):
+        return compiled_property
```

## pytraits/core/primitives/routine_object.py

 * *Ordering differences only*

```diff
@@ -1,124 +1,124 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.support import get_func_name
-from .trait_object import TraitObject
-
-
-class FunctionObject(TraitObject):
-    """ This class encapsulates handling of function objects.
-
-    Generally, there's no functions in terms of traits. Functions are turned to
-    something else since they behave differently depending on the context, like
-    pure functions for class should be staticmethods since they are not likely to
-    do any modifications to class (or instance) itself.
-    """
-    @classmethod
-    def hook_into(cls, inspector):
-        if inspector.TYPE == 'source':
-            inspector.add_hook('function', cls.check)
-
-    @staticmethod
-    def check(object):
-        args = object.__code__.co_varnames
-
-        # Functions without arguments are considered to be static
-        # methods.
-        if len(args) == 0:
-            return StaticMethodObject(object)
-
-        # Function, that has first argument 'self', wants to be method.
-        elif args[0] == 'self':
-            return MethodObject(object)
-
-        # Function, that has first argument 'cls', wants to be classmethod.
-        elif args[0] == 'cls':
-            return ClassMethodObject(object)
-
-        # Other functions are to be static methods.
-        else:
-            return StaticMethodObject(object)
-
-
-class RoutineObject(TraitObject):
-    @property
-    def name(self):
-        return get_func_name(self._object, False)
-
-    @property
-    def compile_target(self):
-        return self._object
-
-    def recompile(self, target, name):
-        return self._compiler.recompile(self.compile_target, target.compile_target, name)
-
-
-class MethodObject(RoutineObject):
-    """ This class encapsulates handling of methods.
-    """
-    INSPECTORS = ('source',)
-
-    def rebind(self, target, source):
-        # TODO: Can this be made prettier?
-        if target.compile_target == target.bind_target:
-            return source.__get__(None, target.compile_target)
-        return source.__get__(target.bind_target, target.compile_target)
-
-
-class ClassMethodObject(RoutineObject):
-    """ This class encapsulates handling of classmethods.
-
-    This class is able handle functions that are decorated with classmethod
-    and pure functions that have 'cls' as a first argument.
-    """
-    INSPECTORS = ('source',)
-
-    @property
-    def compile_target(self):
-        return getattr(self._object, '__func__', self._object)
-
-    def rebind(self, target, source):
-        return source.__get__(target.bind_target, target.bind_target)
-
-
-class StaticMethodObject(RoutineObject):
-    """ This class encapsulates handling of staticmethods.
-    """
-    INSPECTORS = ('source',)
-
-    @property
-    def compile_target(self):
-        return getattr(self._object, '__func__', self._object)
-
-    def rebind(self, target, source):
-        return source.__get__(None, target.compile_target)
-
-
-# TODO: where to go?
-def wrap_builtin(builtin_func):
-    def wrapper(self, *args, **kwargs):
-        return builtin_func(*args, **kwargs)
-    return wrapper
-
-
-class BuiltinObject(MethodObject):
-    """ This class encapsulates handling of builtin functions. """
-    INSPECTORS = ('source',)
-
-    def recompile(self, target, name):
-        return lambda *args, **kwargs: self._object(*args[1:], **kwargs)
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.support import get_func_name
+from .trait_object import TraitObject
+
+
+class FunctionObject(TraitObject):
+    """ This class encapsulates handling of function objects.
+
+    Generally, there's no functions in terms of traits. Functions are turned to
+    something else since they behave differently depending on the context, like
+    pure functions for class should be staticmethods since they are not likely to
+    do any modifications to class (or instance) itself.
+    """
+    @classmethod
+    def hook_into(cls, inspector):
+        if inspector.TYPE == 'source':
+            inspector.add_hook('function', cls.check)
+
+    @staticmethod
+    def check(object):
+        args = object.__code__.co_varnames
+
+        # Functions without arguments are considered to be static
+        # methods.
+        if len(args) == 0:
+            return StaticMethodObject(object)
+
+        # Function, that has first argument 'self', wants to be method.
+        elif args[0] == 'self':
+            return MethodObject(object)
+
+        # Function, that has first argument 'cls', wants to be classmethod.
+        elif args[0] == 'cls':
+            return ClassMethodObject(object)
+
+        # Other functions are to be static methods.
+        else:
+            return StaticMethodObject(object)
+
+
+class RoutineObject(TraitObject):
+    @property
+    def name(self):
+        return get_func_name(self._object, False)
+
+    @property
+    def compile_target(self):
+        return self._object
+
+    def recompile(self, target, name):
+        return self._compiler.recompile(self.compile_target, target.compile_target, name)
+
+
+class MethodObject(RoutineObject):
+    """ This class encapsulates handling of methods.
+    """
+    INSPECTORS = ('source',)
+
+    def rebind(self, target, source):
+        # TODO: Can this be made prettier?
+        if target.compile_target == target.bind_target:
+            return source.__get__(None, target.compile_target)
+        return source.__get__(target.bind_target, target.compile_target)
+
+
+class ClassMethodObject(RoutineObject):
+    """ This class encapsulates handling of classmethods.
+
+    This class is able handle functions that are decorated with classmethod
+    and pure functions that have 'cls' as a first argument.
+    """
+    INSPECTORS = ('source',)
+
+    @property
+    def compile_target(self):
+        return getattr(self._object, '__func__', self._object)
+
+    def rebind(self, target, source):
+        return source.__get__(target.bind_target, target.bind_target)
+
+
+class StaticMethodObject(RoutineObject):
+    """ This class encapsulates handling of staticmethods.
+    """
+    INSPECTORS = ('source',)
+
+    @property
+    def compile_target(self):
+        return getattr(self._object, '__func__', self._object)
+
+    def rebind(self, target, source):
+        return source.__get__(None, target.compile_target)
+
+
+# TODO: where to go?
+def wrap_builtin(builtin_func):
+    def wrapper(self, *args, **kwargs):
+        return builtin_func(*args, **kwargs)
+    return wrapper
+
+
+class BuiltinObject(MethodObject):
+    """ This class encapsulates handling of builtin functions. """
+    INSPECTORS = ('source',)
+
+    def recompile(self, target, name):
+        return lambda *args, **kwargs: self._object(*args[1:], **kwargs)
```

## pytraits/core/primitives/trait_object.py

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from ..base import TraitFactory
-
-
-class TraitObject:
-    FACTORY = TraitFactory()
-
-    def __init__(self, object):
-        self._object = object
-        self._compiler = self.FACTORY["Compiler"]()
-
-    @classmethod
-    def __str__(cls):
-        return cls.__name__.lower().replace('object', '')
-
-    @classmethod
-    def hook_into(cls, inspector):
-        if inspector.TYPE in cls.INSPECTORS:
-            inspector.add_hook(cls.__str__(), cls)
-
-    @property
-    def object(self):
-        return self._object
-
-    @property
-    def qualname(self):
-        try:
-            return self._object.__qualname__
-        except AttributeError:
-            return type(self._object).__name__
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from ..base import TraitFactory
+
+
+class TraitObject:
+    FACTORY = TraitFactory()
+
+    def __init__(self, object):
+        self._object = object
+        self._compiler = self.FACTORY["Compiler"]()
+
+    @classmethod
+    def __str__(cls):
+        return cls.__name__.lower().replace('object', '')
+
+    @classmethod
+    def hook_into(cls, inspector):
+        if inspector.TYPE in cls.INSPECTORS:
+            inspector.add_hook(cls.__str__(), cls)
+
+    @property
+    def object(self):
+        return self._object
+
+    @property
+    def qualname(self):
+        try:
+            return self._object.__qualname__
+        except AttributeError:
+            return type(self._object).__name__
```

## pytraits/core/primitives/unidentified_object.py

 * *Ordering differences only*

```diff
@@ -1,31 +1,31 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from .trait_object import TraitObject
-
-
-class UnidentifiedObject(TraitObject):
-    @classmethod
-    def hook_into(cls, inspector):
-        inspector.set_default_hook(cls)
-
-    def __str__(self):
-        return "Unidentified object"
-
-    def __bool__(self):
-        return False
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from .trait_object import TraitObject
+
+
+class UnidentifiedObject(TraitObject):
+    @classmethod
+    def hook_into(cls, inspector):
+        inspector.set_default_hook(cls)
+
+    def __str__(self):
+        return "Unidentified object"
+
+    def __bool__(self):
+        return False
```

## pytraits/core/primitives/__init__.py

 * *Ordering differences only*

```diff
@@ -1,49 +1,49 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-import pkgutil
-import importlib
-from os.path import dirname
-from pytraits.support import is_sysname
-from ..base.inspectors import TraitSourceInspector, TraitTargetInspector
-
-# Import each module and register their TraitObject based classes to
-# corresponsing inspectors. This mechanism allows us to add new modules and
-# classes without need to do any other steps to get them registered into
-# inspectors.
-for _, module_name, _ in pkgutil.iter_modules([dirname(__file__)]):
-    module = importlib.import_module("{}.{}".format(__package__, module_name))
-
-    for object_name in dir(module):
-        if is_sysname(object_name):
-            continue
-
-        object = getattr(module, object_name)
-
-        try:
-            object.hook_into(TraitSourceInspector)
-            object.hook_into(TraitTargetInspector)
-        except AttributeError:
-            pass
-
-# Let's remove the option of modifying the singletons after we are done with
-# this.
-TraitTargetInspector.add_hook = None
-TraitTargetInspector.add_default_hook = None
-TraitSourceInspector.add_hook = None
-TraitSourceInspector.add_default_hook = None
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+import pkgutil
+import importlib
+from os.path import dirname
+from pytraits.support import is_sysname
+from ..base.inspectors import TraitSourceInspector, TraitTargetInspector
+
+# Import each module and register their TraitObject based classes to
+# corresponsing inspectors. This mechanism allows us to add new modules and
+# classes without need to do any other steps to get them registered into
+# inspectors.
+for _, module_name, _ in pkgutil.iter_modules([dirname(__file__)]):
+    module = importlib.import_module("{}.{}".format(__package__, module_name))
+
+    for object_name in dir(module):
+        if is_sysname(object_name):
+            continue
+
+        object = getattr(module, object_name)
+
+        try:
+            object.hook_into(TraitSourceInspector)
+            object.hook_into(TraitTargetInspector)
+        except AttributeError:
+            pass
+
+# Let's remove the option of modifying the singletons after we are done with
+# this.
+TraitTargetInspector.add_hook = None
+TraitTargetInspector.add_default_hook = None
+TraitSourceInspector.add_hook = None
+TraitSourceInspector.add_default_hook = None
```

## pytraits/support/errors.py

 * *Ordering differences only*

```diff
@@ -1,44 +1,44 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-# TODO: This is probably in wrong place
-# Exceptions
-UnextendableObjectError = "Target context can be only class or instance of class"
-FactoryError = "Factory is abstract, inherit your own!"
-FactoryClassMissingError = "Class is missing!"
-FactoryRegisterError = "Already registered!"
-SingletonError = 'Singletons are immutable!'
-SingletonInstanceError = 'Singleton with arguments has already been created!'
-BuiltinSourceError = 'Built-in objects can not used as traits!'
-PropertySourceError = 'Properties can not be extended!'
-TypeConversionError = 'Conversion impossible!'
-ArgumentValueError = 'Unexpected value!'
-FirstTraitArgumentError = 'First argument must not be string!'
-TraitArgumentTypeError = "Expected list of trait names for given source object!"
-
-
-# Convert strings to exception objects
-for exception, message in dict(globals()).items():
-    if not exception.endswith('Error'):
-        continue
-
-    bases = (Exception,)
-    attrs = {'__default_msg': message,
-             '__init__': lambda self, msg=None: setattr(self, '__msg', msg),
-             '__str__': lambda self: self.__msg or self.__default_msg}
-    globals()[exception] = type(exception, bases, attrs)
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+# TODO: This is probably in wrong place
+# Exceptions
+UnextendableObjectError = "Target context can be only class or instance of class"
+FactoryError = "Factory is abstract, inherit your own!"
+FactoryClassMissingError = "Class is missing!"
+FactoryRegisterError = "Already registered!"
+SingletonError = 'Singletons are immutable!'
+SingletonInstanceError = 'Singleton with arguments has already been created!'
+BuiltinSourceError = 'Built-in objects can not used as traits!'
+PropertySourceError = 'Properties can not be extended!'
+TypeConversionError = 'Conversion impossible!'
+ArgumentValueError = 'Unexpected value!'
+FirstTraitArgumentError = 'First argument must not be string!'
+TraitArgumentTypeError = "Expected list of trait names for given source object!"
+
+
+# Convert strings to exception objects
+for exception, message in dict(globals()).items():
+    if not exception.endswith('Error'):
+        continue
+
+    bases = (Exception,)
+    attrs = {'__default_msg': message,
+             '__init__': lambda self, msg=None: setattr(self, '__msg', msg),
+             '__str__': lambda self: self.__msg or self.__default_msg}
+    globals()[exception] = type(exception, bases, attrs)
```

## pytraits/support/factory.py

 * *Ordering differences only*

```diff
@@ -1,157 +1,157 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-import inspect
-
-from pytraits.support import Singleton
-from pytraits.support.errors import (FactoryError,
-                                     FactoryRegisterError,
-                                     FactoryClassMissingError)
-
-__all__ = ["Factory"]
-
-
-class FactoryType(Singleton):
-    """ Convenience type for factory to allow dictionary type access to objects."""
-    def __getitem__(cls, name):
-        return cls()[name]
-
-    def __call__(cls, *args, **kwargs):
-        if cls is Factory:
-            raise FactoryError()
-        return super().__call__(*args, **kwargs)
-
-
-class Factory(metaclass=FactoryType):
-    """ Simple factory to register and create objects.
-
-    This class contains multiple ways to hold and create instances of classes.
-    This class also works as a container for all those classes that are
-    registered in and can those classes can be accessed from anywhere by simply
-    importing that factory.
-
-    The main mechanism in python to create and initialize objects are __new__
-    and __init__ functions. It is also a good habit to avoid any conditional
-    logic inside class constructor, thus writing own create classmethod is
-    recommended and also supported by this factory. By using own class method
-    for creating the object, it makes far more easier to setup and test classes
-    you write since the __init__ method is left for simple assignments.
-
-    NOTE: This factory is abstract thus anyone using it must inherit own
-          version before instantiating it.
-
-    >>> class ExampleFactory(Factory):
-    ...     pass
-    ...
-    >>> @ExampleFactory.register
-    ... class ExampleObject:
-    ...     def __init__(self, name, **kwargs):
-    ...         self.name = name
-    ...
-    ...     @classmethod
-    ...     def create(cls, *args, **kwargs):
-    ...         return cls(*args, **kwargs)
-    ...
-    >>> example_instance = ExampleFactory["ExampleObject"]("MyObject")
-    >>> example_instance.name
-    'MyObject'
-    """
-    def __init__(self, override_duplicates=False):
-        self.__methods = {}
-        self.__classes = {}
-        self.__override_duplicates = override_duplicates
-
-    @classmethod
-    def register(cls, *classes, override=False, autoinit=True):
-        """ Decorator function to register classes to this factory. """
-        assert classes, "No classes provided!"
-
-        # This is singleton, so we can get the singleton instance directly
-        # here and start filling it.
-        self = cls()
-        for clazz in classes:
-            self.__register(clazz, override=override, autoinit=autoinit)
-
-        # When single class is registered, return it too so that
-        # this function can act as a class decorator.
-        if len(classes) == 1:
-            return classes[0]
-
-    def __register(self, clazz, override, autoinit):
-        assert inspect.isclass(clazz)
-
-        # Make sure duplicates are not registered. By default, raise error
-        # in order to avoid weird debugging errors. Duplicates, if tolerated,
-        # can be
-        override |= self.__override_duplicates
-        if self.exists(clazz) and not override:
-            # TODO: Record traceback for each registered object.
-            msg = "Name '{}' already found from factory"
-            raise FactoryRegisterError(msg.format(clazz.__name__))
-
-        # Keep a list of classes in case there is a need to override them.
-        self.__classes[clazz.__name__] = clazz
-
-        # In case the clazz defines __call__ function, it is considered
-        # as subfactory, which means we try to initialize the clazz
-        # and use it's instance as a factory method. Setting autoinit to
-        # False will of course prevent that behavior.
-        if "__call__" in dir(clazz) and autoinit:
-            self.__methods[clazz.__name__] = getattr(clazz, 'create', clazz)()
-        else:
-            self.__methods[clazz.__name__] = getattr(clazz, 'create', clazz)
-
-        return clazz
-
-    def __access(self, collection, name):
-        try:
-            return collection[name]
-        except KeyError:
-            msg = "Name '{}' is not in registered list: {}"
-            msg = msg.format(name, self.registered_classes)
-            raise FactoryClassMissingError(msg)
-
-    def __getitem__(self, name):
-        """ Returns factory method of registered object.
-
-        @see constructor
-        """
-        return self.__access(self.__methods, name)
-
-    def exists(self, clazz):
-        """ Convenience function to check if class is already exists. """
-        return clazz.__name__ in self.__classes
-
-    def original_class(self, name):
-        """ Retrieves the original registered class. """
-        return self.__access(self.__classes, name)
-
-    @classmethod
-    def reset(cls):
-        """ Removes all registered classes. """
-        cls().__methods.clear()
-        cls().__classes.clear()
-
-    @property
-    def registered_classes(self):
-        return list(self.__classes.keys())
-
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+import inspect
+
+from pytraits.support import Singleton
+from pytraits.support.errors import (FactoryError,
+                                     FactoryRegisterError,
+                                     FactoryClassMissingError)
+
+__all__ = ["Factory"]
+
+
+class FactoryType(Singleton):
+    """ Convenience type for factory to allow dictionary type access to objects."""
+    def __getitem__(cls, name):
+        return cls()[name]
+
+    def __call__(cls, *args, **kwargs):
+        if cls is Factory:
+            raise FactoryError()
+        return super().__call__(*args, **kwargs)
+
+
+class Factory(metaclass=FactoryType):
+    """ Simple factory to register and create objects.
+
+    This class contains multiple ways to hold and create instances of classes.
+    This class also works as a container for all those classes that are
+    registered in and can those classes can be accessed from anywhere by simply
+    importing that factory.
+
+    The main mechanism in python to create and initialize objects are __new__
+    and __init__ functions. It is also a good habit to avoid any conditional
+    logic inside class constructor, thus writing own create classmethod is
+    recommended and also supported by this factory. By using own class method
+    for creating the object, it makes far more easier to setup and test classes
+    you write since the __init__ method is left for simple assignments.
+
+    NOTE: This factory is abstract thus anyone using it must inherit own
+          version before instantiating it.
+
+    >>> class ExampleFactory(Factory):
+    ...     pass
+    ...
+    >>> @ExampleFactory.register
+    ... class ExampleObject:
+    ...     def __init__(self, name, **kwargs):
+    ...         self.name = name
+    ...
+    ...     @classmethod
+    ...     def create(cls, *args, **kwargs):
+    ...         return cls(*args, **kwargs)
+    ...
+    >>> example_instance = ExampleFactory["ExampleObject"]("MyObject")
+    >>> example_instance.name
+    'MyObject'
+    """
+    def __init__(self, override_duplicates=False):
+        self.__methods = {}
+        self.__classes = {}
+        self.__override_duplicates = override_duplicates
+
+    @classmethod
+    def register(cls, *classes, override=False, autoinit=True):
+        """ Decorator function to register classes to this factory. """
+        assert classes, "No classes provided!"
+
+        # This is singleton, so we can get the singleton instance directly
+        # here and start filling it.
+        self = cls()
+        for clazz in classes:
+            self.__register(clazz, override=override, autoinit=autoinit)
+
+        # When single class is registered, return it too so that
+        # this function can act as a class decorator.
+        if len(classes) == 1:
+            return classes[0]
+
+    def __register(self, clazz, override, autoinit):
+        assert inspect.isclass(clazz)
+
+        # Make sure duplicates are not registered. By default, raise error
+        # in order to avoid weird debugging errors. Duplicates, if tolerated,
+        # can be
+        override |= self.__override_duplicates
+        if self.exists(clazz) and not override:
+            # TODO: Record traceback for each registered object.
+            msg = "Name '{}' already found from factory"
+            raise FactoryRegisterError(msg.format(clazz.__name__))
+
+        # Keep a list of classes in case there is a need to override them.
+        self.__classes[clazz.__name__] = clazz
+
+        # In case the clazz defines __call__ function, it is considered
+        # as subfactory, which means we try to initialize the clazz
+        # and use it's instance as a factory method. Setting autoinit to
+        # False will of course prevent that behavior.
+        if "__call__" in dir(clazz) and autoinit:
+            self.__methods[clazz.__name__] = getattr(clazz, 'create', clazz)()
+        else:
+            self.__methods[clazz.__name__] = getattr(clazz, 'create', clazz)
+
+        return clazz
+
+    def __access(self, collection, name):
+        try:
+            return collection[name]
+        except KeyError:
+            msg = "Name '{}' is not in registered list: {}"
+            msg = msg.format(name, self.registered_classes)
+            raise FactoryClassMissingError(msg)
+
+    def __getitem__(self, name):
+        """ Returns factory method of registered object.
+
+        @see constructor
+        """
+        return self.__access(self.__methods, name)
+
+    def exists(self, clazz):
+        """ Convenience function to check if class is already exists. """
+        return clazz.__name__ in self.__classes
+
+    def original_class(self, name):
+        """ Retrieves the original registered class. """
+        return self.__access(self.__classes, name)
+
+    @classmethod
+    def reset(cls):
+        """ Removes all registered classes. """
+        cls().__methods.clear()
+        cls().__classes.clear()
+
+    @property
+    def registered_classes(self):
+        return list(self.__classes.keys())
+
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## pytraits/support/inspector.py

 * *Ordering differences only*

```diff
@@ -1,291 +1,291 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-import inspect
-from collections import OrderedDict as odict
-
-from pytraits.support.magic import type_safe
-
-__all__ = ["Inspector"]
-
-
-def isproperty(object):
-    """ Convinience method to check if object is property. """
-    return isinstance(object, property)
-
-
-def isbuiltin(object):
-    """ Convinience method to check if object is builtin. """
-    if inspect.isbuiltin(object):
-        return True
-
-    return getattr(object, '__module__', None) == 'builtins'
-
-
-def isclass(object):
-    """ Convinience method to check if object is class. """
-    if not inspect.isclass(object):
-        return False
-    if isbuiltin(object):
-        return False
-    return type not in inspect.getmro(object)
-
-
-def ismetaclass(object):
-    """ Convinience method to check if object is meta class. """
-    if not inspect.isclass(object):
-        return False
-    if isbuiltin(object):
-        return False
-    return type in inspect.getmro(object)
-
-
-def _get_dict_function(object):
-    try:
-        return object.__self__.__dict__[object.__name__]
-    except (AttributeError, KeyError):
-        return None
-
-
-def isclassmethod(object):
-    """ Convinience method to check if object is class method. """
-    if isinstance(object, classmethod):
-        return True
-
-    # Let's not give up quite yet.
-    original = _get_dict_function(object)
-    return isinstance(original, classmethod)
-
-
-def isdatatype(object):
-    """ Convinience method to check if object is data type. """
-    return isinstance(object, (str, int, bool, float, type(None)))
-
-
-def isstaticmethod(object):
-    """ Convinience method to check if object is static method. """
-    # TODO: This can only identify those static methods that
-    #       are directly taken from object's dict. Like
-    #       Class.__dict__[staticmethodname]
-    if isinstance(object, staticmethod):
-        return True
-
-    if not inspect.isfunction(object):
-        return False
-
-    # Module level functions are disqualified here.
-    if "." not in getattr(object, "__qualname__", ""):
-        return False
-
-    # It is either method (accessed as Class.method) or staticfunction
-    # TODO: Is this really the only way?
-    args = object.__code__.co_varnames
-    if len(args) == 0:
-        return True
-
-    return args[0] != 'self'
-
-
-def isclassinstance(object):
-    """ Convinience method to check if object is class instance. """
-    if not hasattr(object, "__class__"):
-        return False
-    if isbuiltin(object.__class__):
-        return False
-    return True
-
-
-class Inspector:
-    """ Class for inspecting and hooking types. """
-    TYPES = odict([('builtin', isbuiltin),
-                   ('module', inspect.ismodule),
-                   ('property', isproperty),
-                   ('code', inspect.iscode),
-                   ('generator', inspect.isgenerator),
-                   ('traceback', inspect.istraceback),
-                   ('frame', inspect.isframe),
-                   ('staticmethod', isstaticmethod),
-                   ('classmethod', isclassmethod),
-                   ('method', inspect.ismethod),
-                   ('function', inspect.isfunction),
-                   ('routine', inspect.isroutine),
-                   ('methoddescriptor', inspect.ismethoddescriptor),
-                   ('generatorfunction', inspect.isgeneratorfunction),
-                   ('datadescriptor', inspect.isdatadescriptor),
-                   ('memberdescriptor', inspect.ismemberdescriptor),
-                   ('getsetdescriptor', inspect.isgetsetdescriptor),
-                   ('descriptor', isclassmethod),
-                   ('metaclass', ismetaclass),
-                   ('class', isclass),
-                   ('data', isdatatype),
-                   ('instance', isclassinstance)])
-    TYPENAMES = tuple(TYPES.keys())
-
-    def __init__(self, custom_types: odict=None):
-        self.__custom_types = custom_types or odict()
-        self.__hooks = odict()
-        self.__default_hook = None
-
-    def __iter__(self):
-        # Favor custom types. It is possible to override default behavior.
-        yield from self.__custom_types.items()
-        yield from self.TYPES.items()
-
-    @type_safe
-    def __getitem__(self, typename: str):
-        """ Get check function for typename
-
-        >>> Inspector()["class"].__name__
-        'isclass'
-        """
-        try:
-            return self.TYPES[typename]
-        except KeyError:
-            return self.__custom_types[typename]
-
-    @type_safe
-    def inspect_many(self, *objects, all: bool=False):
-        """ Identify all arguments to certain type.
-
-        This function identifies all arguments to certain type and for those
-        types that have a registered hook, will be called with given object for
-        any special handling needed for that type.
-
-        Returns:
-            List of identified objects.
-        """
-        inspected = []
-        for object in objects:
-            inspected.append(self.__inspect_arg(object))
-
-        return inspected
-
-    @type_safe
-    def inspect(self, object, hooked_only: bool=True):
-        """ Identifies type of single object.
-
-        Loops over every type check defined in Inspector.TYPES dictionary and
-        returns type for the first check that qualifies the object.
-
-        Args:
-            object (anything): Object needs to be identified.
-            hooked_only (bool): Switch to decide whether all types are checked
-                                or only hooks. If no hooks are defined then
-                                check is done against all types.
-                                Default is only hooked.
-
-        Return:
-            If no hook found, then name of object type.
-            If hook is found, then any object returned by hook.
-        """
-        for typename, check in self:
-            # Skip checks if it is not required for this type.
-            if hooked_only and len(self.__hooks) and typename not in self.__hooks:
-                continue
-
-            # Keep going if object is not matching.
-            if not check(object):
-                continue
-
-            if typename in self.__hooks:
-                return self.__hooks[typename](object)
-            elif self.__default_hook:
-                return self.__default_hook(object)
-            else:
-                return typename
-
-        # Situation that occurs when receiving a type checks are not covering.
-        if self.__default_hook:
-            return self.__default_hook(object)
-        return None
-
-    @type_safe
-    def add_typecheck(self, name: str, callable=None):
-        """ Adds typecheck for given name.
-
-        This method allows adding custom typechecks. It's possible to either
-        add completely new checks or override existing ones.
-
-        Args:
-            name: Name of the type check. If the name is found from the
-                  Inspector.TYPES list, it will be overridden as new check for
-                  that type. If name is completely new one, then it will be
-                  added as a custom typecheck.
-            callable: Any callable object taking single argument as parameter
-                      and returns True or False as an answer. If None, existing
-                      type check is promoted to be custom. This changes priority
-                      of checks so that desired checks are run earlier.
-
-        Raises:
-            ValueError when there already is a custom type check for given name.
-        """
-        if name in self.__custom_types:
-            raise ValueError("Type '{}' already exists".format(name))
-        self.__custom_types[name] = callable or self.TYPES[name]
-
-    @type_safe
-    def del_typecheck(self, name: str):
-        """ Removes custom type checks by name. """
-        try:
-            del self.__custom_types[name]
-        except KeyError:
-            pass
-
-    @type_safe
-    def add_hook(self, name: str, callable):
-        """ Add hook that is called for given type.
-
-        Args:
-            name: Type name.
-            callable: Any callable taking object as an argument.
-        """
-        assert name in self.typenames, "'{}' not in '{}'".format(name, self.typenames)
-        self.__hooks[name] = callable
-
-    @type_safe
-    def del_hook(self, name: str):
-        """ Removes a hook by name. """
-        try:
-            del self.__hooks[name]
-        except KeyError:
-            pass
-
-    def set_default_hook(self, callable):
-        self.__default_hook = callable
-
-    def del_default_hook(self):
-        self.__default_hook = None
-
-    def clear(self):
-        """ Removes all the hooks. """
-        self.__hooks = odict()
-
-    @property
-    def hooks(self):
-        """ Tuple of registered hooks. """
-        return tuple(self.__hooks.keys())
-
-    @property
-    def typenames(self):
-        """ Tuple of supported types """
-        return tuple((item[0] for item in self))
-
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+import inspect
+from collections import OrderedDict as odict
+
+from pytraits.support.magic import type_safe
+
+__all__ = ["Inspector"]
+
+
+def isproperty(object):
+    """ Convinience method to check if object is property. """
+    return isinstance(object, property)
+
+
+def isbuiltin(object):
+    """ Convinience method to check if object is builtin. """
+    if inspect.isbuiltin(object):
+        return True
+
+    return getattr(object, '__module__', None) == 'builtins'
+
+
+def isclass(object):
+    """ Convinience method to check if object is class. """
+    if not inspect.isclass(object):
+        return False
+    if isbuiltin(object):
+        return False
+    return type not in inspect.getmro(object)
+
+
+def ismetaclass(object):
+    """ Convinience method to check if object is meta class. """
+    if not inspect.isclass(object):
+        return False
+    if isbuiltin(object):
+        return False
+    return type in inspect.getmro(object)
+
+
+def _get_dict_function(object):
+    try:
+        return object.__self__.__dict__[object.__name__]
+    except (AttributeError, KeyError):
+        return None
+
+
+def isclassmethod(object):
+    """ Convinience method to check if object is class method. """
+    if isinstance(object, classmethod):
+        return True
+
+    # Let's not give up quite yet.
+    original = _get_dict_function(object)
+    return isinstance(original, classmethod)
+
+
+def isdatatype(object):
+    """ Convinience method to check if object is data type. """
+    return isinstance(object, (str, int, bool, float, type(None)))
+
+
+def isstaticmethod(object):
+    """ Convinience method to check if object is static method. """
+    # TODO: This can only identify those static methods that
+    #       are directly taken from object's dict. Like
+    #       Class.__dict__[staticmethodname]
+    if isinstance(object, staticmethod):
+        return True
+
+    if not inspect.isfunction(object):
+        return False
+
+    # Module level functions are disqualified here.
+    if "." not in getattr(object, "__qualname__", ""):
+        return False
+
+    # It is either method (accessed as Class.method) or staticfunction
+    # TODO: Is this really the only way?
+    args = object.__code__.co_varnames
+    if len(args) == 0:
+        return True
+
+    return args[0] != 'self'
+
+
+def isclassinstance(object):
+    """ Convinience method to check if object is class instance. """
+    if not hasattr(object, "__class__"):
+        return False
+    if isbuiltin(object.__class__):
+        return False
+    return True
+
+
+class Inspector:
+    """ Class for inspecting and hooking types. """
+    TYPES = odict([('builtin', isbuiltin),
+                   ('module', inspect.ismodule),
+                   ('property', isproperty),
+                   ('code', inspect.iscode),
+                   ('generator', inspect.isgenerator),
+                   ('traceback', inspect.istraceback),
+                   ('frame', inspect.isframe),
+                   ('staticmethod', isstaticmethod),
+                   ('classmethod', isclassmethod),
+                   ('method', inspect.ismethod),
+                   ('function', inspect.isfunction),
+                   ('routine', inspect.isroutine),
+                   ('methoddescriptor', inspect.ismethoddescriptor),
+                   ('generatorfunction', inspect.isgeneratorfunction),
+                   ('datadescriptor', inspect.isdatadescriptor),
+                   ('memberdescriptor', inspect.ismemberdescriptor),
+                   ('getsetdescriptor', inspect.isgetsetdescriptor),
+                   ('descriptor', isclassmethod),
+                   ('metaclass', ismetaclass),
+                   ('class', isclass),
+                   ('data', isdatatype),
+                   ('instance', isclassinstance)])
+    TYPENAMES = tuple(TYPES.keys())
+
+    def __init__(self, custom_types: odict=None):
+        self.__custom_types = custom_types or odict()
+        self.__hooks = odict()
+        self.__default_hook = None
+
+    def __iter__(self):
+        # Favor custom types. It is possible to override default behavior.
+        yield from self.__custom_types.items()
+        yield from self.TYPES.items()
+
+    @type_safe
+    def __getitem__(self, typename: str):
+        """ Get check function for typename
+
+        >>> Inspector()["class"].__name__
+        'isclass'
+        """
+        try:
+            return self.TYPES[typename]
+        except KeyError:
+            return self.__custom_types[typename]
+
+    @type_safe
+    def inspect_many(self, *objects, all: bool=False):
+        """ Identify all arguments to certain type.
+
+        This function identifies all arguments to certain type and for those
+        types that have a registered hook, will be called with given object for
+        any special handling needed for that type.
+
+        Returns:
+            List of identified objects.
+        """
+        inspected = []
+        for object in objects:
+            inspected.append(self.__inspect_arg(object))
+
+        return inspected
+
+    @type_safe
+    def inspect(self, object, hooked_only: bool=True):
+        """ Identifies type of single object.
+
+        Loops over every type check defined in Inspector.TYPES dictionary and
+        returns type for the first check that qualifies the object.
+
+        Args:
+            object (anything): Object needs to be identified.
+            hooked_only (bool): Switch to decide whether all types are checked
+                                or only hooks. If no hooks are defined then
+                                check is done against all types.
+                                Default is only hooked.
+
+        Return:
+            If no hook found, then name of object type.
+            If hook is found, then any object returned by hook.
+        """
+        for typename, check in self:
+            # Skip checks if it is not required for this type.
+            if hooked_only and len(self.__hooks) and typename not in self.__hooks:
+                continue
+
+            # Keep going if object is not matching.
+            if not check(object):
+                continue
+
+            if typename in self.__hooks:
+                return self.__hooks[typename](object)
+            elif self.__default_hook:
+                return self.__default_hook(object)
+            else:
+                return typename
+
+        # Situation that occurs when receiving a type checks are not covering.
+        if self.__default_hook:
+            return self.__default_hook(object)
+        return None
+
+    @type_safe
+    def add_typecheck(self, name: str, callable=None):
+        """ Adds typecheck for given name.
+
+        This method allows adding custom typechecks. It's possible to either
+        add completely new checks or override existing ones.
+
+        Args:
+            name: Name of the type check. If the name is found from the
+                  Inspector.TYPES list, it will be overridden as new check for
+                  that type. If name is completely new one, then it will be
+                  added as a custom typecheck.
+            callable: Any callable object taking single argument as parameter
+                      and returns True or False as an answer. If None, existing
+                      type check is promoted to be custom. This changes priority
+                      of checks so that desired checks are run earlier.
+
+        Raises:
+            ValueError when there already is a custom type check for given name.
+        """
+        if name in self.__custom_types:
+            raise ValueError("Type '{}' already exists".format(name))
+        self.__custom_types[name] = callable or self.TYPES[name]
+
+    @type_safe
+    def del_typecheck(self, name: str):
+        """ Removes custom type checks by name. """
+        try:
+            del self.__custom_types[name]
+        except KeyError:
+            pass
+
+    @type_safe
+    def add_hook(self, name: str, callable):
+        """ Add hook that is called for given type.
+
+        Args:
+            name: Type name.
+            callable: Any callable taking object as an argument.
+        """
+        assert name in self.typenames, "'{}' not in '{}'".format(name, self.typenames)
+        self.__hooks[name] = callable
+
+    @type_safe
+    def del_hook(self, name: str):
+        """ Removes a hook by name. """
+        try:
+            del self.__hooks[name]
+        except KeyError:
+            pass
+
+    def set_default_hook(self, callable):
+        self.__default_hook = callable
+
+    def del_default_hook(self):
+        self.__default_hook = None
+
+    def clear(self):
+        """ Removes all the hooks. """
+        self.__hooks = odict()
+
+    @property
+    def hooks(self):
+        """ Tuple of registered hooks. """
+        return tuple(self.__hooks.keys())
+
+    @property
+    def typenames(self):
+        """ Tuple of supported types """
+        return tuple((item[0] for item in self))
+
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## pytraits/support/magic.py

 * *Ordering differences only*

```diff
@@ -1,342 +1,342 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-import inspect
-import itertools
-import functools
-
-from pytraits.support.errors import TypeConversionError, ArgumentValueError
-from pytraits.support.utils import get_func_name
-from pytraits.support.utils import get_signature
-
-
-__all__ = ["type_safe", "type_converted"]
-
-
-class ErrorMessage:
-    """
-    Encapsulates building of error message.
-    """
-    def __init__(self, main_msg, repeat_msg, get_func_name):
-        self.__errors = []
-        self.__get_func_name = get_func_name
-        self.__main_msg = main_msg
-        self.__repeat_msg = repeat_msg
-
-    def __bool__(self):
-        return bool(self.__errors)
-
-    def __str__(self):
-        msg = [self.__main_msg.format(self.__get_func_name)]
-        for error in self.__errors:
-            msg.append("   - " + self.__repeat_msg.format(**error))
-        return "\n".join(msg)
-
-    def set_main_messsage(self, msg):
-        self.__main_msg = msg
-
-    def set_repeat_message(self, msg):
-        self.__repeat_msg = msg
-
-    def add(self, **kwargs):
-        self.__errors.append(kwargs)
-
-    def reset(self):
-        self.__errors = []
-
-
-class type_safe:
-    """
-    Decorator to enforce type safety. It certainly kills some ducks
-    but allows us also to fail fast.
-
-    >>> @type_safe
-    ... def check(value: int, answer: bool, anything):
-    ...     return value, answer, anything
-    ...
-
-    >>> check("12", "false", True)
-    Traceback (most recent call last):
-    ...
-    TypeError: While calling check(value:int, answer:bool, anything):
-       - parameter 'value' had value '12' of type 'str'
-       - parameter 'answer' had value 'false' of type 'str'
-
-    >>> check(1000, True)
-    Traceback (most recent call last):
-    ...
-    TypeError: check() missing 1 required positional argument: 'anything'
-    """
-    def __init__(self, function):
-        self._function = function
-        functools.update_wrapper(self, function)
-        self.__signature = inspect.signature(function)
-        self._specs = inspect.getfullargspec(self._function)
-        self._self = None
-        self._errors = ErrorMessage(
-            'While calling {}:',
-            "parameter '{name}' had value '{value}' of type '{typename}'",
-            get_signature(function))
-
-    def __get__(self, instance, clazz):
-        """
-        Stores calling instances and returns this decorator object as function.
-        """
-        # In Python, every function is a property. Before Python invokes function,
-        # it must access the function using __get__, where it can deliver the calling
-        # object. After the __get__, function is ready for being invoked by __call__.
-        self._self = instance
-        return self
-
-    def iter_positional_args(self, args):
-        """
-        Yields type, name, value combination of function arguments.
-        """
-        # specs.args contains all arguments of the function. Loop here all
-        # argument names and their values putting them together. If there
-        # are arguments missing values, fill them with None.
-        for name, val in itertools.zip_longest(self._specs.args, args, fillvalue=None):
-            # __annotations__ is a dictionary of argument name and annotation.
-            # We accept empty annotations, in which case the argument has no
-            # type requirement.
-            yield self._function.__annotations__.get(name, None), name, val
-
-    def _analyze_args(self, args):
-        """
-        Invoked by __call__ in order to work with positional arguments.
-
-        This function does the actual work of evaluating arguments against
-        their annotations. Any deriving class can override this function
-        to do different kind of handling for the arguments. Overriding function
-        must return list of arguments that will be used to call the decorated
-        function.
-
-        @param args: Arguments given for the function.
-        @return same list of arguments given in parameter.
-        """
-        # TODO: inspect.Signature does quite lot of similar things. Figure
-        #       out, how to take advantage of that.
-        for arg_type, arg_name, arg_value in self.iter_positional_args(args):
-            if not arg_type or isinstance(arg_value, arg_type):
-                continue
-
-            self._errors.add(
-                typename=type(arg_value).__name__,
-                name=arg_name,
-                value=arg_value)
-
-        if self._errors:
-            raise TypeError(str(self._errors))
-
-        return args
-
-    def __match_arg_count(self, args):
-        """
-        Verifies that proper number of arguments are given to function.
-        """
-        # With default values this verification is bit tricky. In case
-        # given arguments match with number of arguments in function signature,
-        # we can proceed.
-        if len(args) == len(self._specs.args):
-            return True
-
-        # It's possible to have less arguments given than defined in function
-        # signature in case any default values exist.
-        if len(args) - len(self._specs.defaults or []) == len(self._specs.args):
-            return True
-
-        # When exceeding number of args, also check if function accepts
-        # indefinite number of positional arguments.
-        if len(args) > len(self._specs.args) and self._specs.varargs:
-            return True
-
-        # We got either too many arguments or too few.
-        return False
-
-    def __call__(self, *args, **kwargs):
-        """
-        Converts annotated types into proper type and calls original function.
-        """
-        self._errors.reset()
-
-        # Methods require instance of the class to be first argument. We
-        # stored it in __get__ and now add it to argument list so that
-        # function can be invoked correctly.
-        if self._self:
-            args = (self._self, ) + args
-
-        # Before doing any type checks, make sure argument count matches.
-        if self.__match_arg_count(args):
-            args = self._analyze_args(args)
-
-        return self._function(*args, **kwargs)
-
-
-class type_converted(type_safe):
-    """
-    Decorator to enforce types and do auto conversion to values.
-
-    >>> @type_converted
-    ... def convert(value: int, answer: bool, anything):
-    ...     return value, answer, anything
-    ...
-    >>> convert("12", "false", None)
-    (12, False, None)
-
-    >>> class Example:
-    ...     @type_converted
-    ...     def convert(self, value: int, answer: bool, anything):
-    ...       return value, answer, anything
-    ...
-    >>> Example().convert("12", 0, "some value")
-    (12, False, 'some value')
-
-    >>> Example().convert(None, None, None)
-    Traceback (most recent call last):
-    ...
-    pytraits.support.errors.TypeConversionError: While calling Example.convert(self, value:int, answer:bool, anything):
-       - got arg 'value' as 'None' of type 'NoneType' which cannot be converted to 'int'
-       - got arg 'answer' as 'None' of type 'NoneType' which cannot be converted to 'bool'
-    """
-    def __init__(self, function):
-        super().__init__(function)
-        self.__converters = {bool: self.boolean_conversion}
-        self._errors = ErrorMessage(
-            'While calling {}:',
-            "got arg '{name}' as '{value}' of type '{typename}' "
-            "which cannot be converted to '{expectedtype}'",
-            get_signature(function))
-
-    def convert(self, arg_type, arg_name, arg_value):
-        """
-        Converts argument to given type.
-        """
-        # If no type required, return value as is.
-        if arg_type is None:
-            return arg_value
-
-        try:
-            return self.__converters[arg_type](arg_value)
-        except KeyError:
-            return arg_type(arg_value)
-
-    def boolean_conversion(self, value):
-        """
-        Convert given value to boolean.
-
-        >>> conv = type_converted(lambda self: None)
-        >>> conv.boolean_conversion("True"), conv.boolean_conversion("false")
-        (True, False)
-
-        >>> conv.boolean_conversion(1), conv.boolean_conversion(0)
-        (True, False)
-        """
-        if isinstance(value, bool):
-            return value
-
-        elif isinstance(value, str):
-            if value.lower() == "true":
-                return True
-            if value.lower() == "false":
-                return False
-
-        elif isinstance(value, int):
-            if not value:
-                return False
-            if value == 1:
-                return True
-
-        raise TypeConversionError()  # This will be caught by convert method.
-
-    def _analyze_args(self, args):
-        """
-        Converts annotated types into proper type and calls original function.
-        """
-        self._errors.reset()
-        new_args = []
-
-        for arg_type, arg_name, arg_value in self.iter_positional_args(args):
-            try:
-                new_args.append(self.convert(arg_type, arg_name, arg_value))
-            except (TypeConversionError, TypeError):
-                self._errors.add(
-                    name=arg_name,
-                    value=arg_value,
-                    typename=type(arg_value).__name__,
-                    expectedtype=arg_type.__name__)
-
-        if self._errors:
-            raise TypeConversionError(str(self._errors))
-
-        return new_args
-
-
-class validation(type_safe):
-    """ Class to validate attributes against given values
-
-    >>> @validation
-    ... def show_number(number: (1, 2, 3, 5)):
-    ...     return number
-    ...
-    >>> show_number(1), show_number(2), show_number(3), show_number(5)
-    (1, 2, 3, 5)
-
-    >>> show_number(4)
-    Traceback (most recent call last):
-    ...
-    pytraits.support.errors.ArgumentValueError: While calling 'show_number':
-       - got arg 'number' as '4' of type 'int' which is not any of these values: (1, 2, 3, 5)
-
-    >>> show_number("5")
-    Traceback (most recent call last):
-    ...
-    pytraits.support.errors.ArgumentValueError: While calling 'show_number':
-       - got arg 'number' as '5' of type 'str' which is not any of these values: (1, 2, 3, 5)
-    """
-    def __init__(self, function):
-        super().__init__(function)
-        self.__function = function
-        self._errors = ErrorMessage(
-            "While calling '{}':",
-            "got arg '{name}' as '{value}' of type '{typename}' "
-            "which is not any of these values: {values}",
-            get_func_name(function))
-
-    def _analyze_args(self, args):
-        self._errors.reset()
-
-        for arg_values, arg_name, arg_value in self.iter_positional_args(args):
-            if not arg_values:
-                continue
-
-            arg_values = tuple([arg_values]) if not isinstance(arg_values, tuple) else arg_values
-            if arg_value not in arg_values:
-                self._errors.add(name=arg_name,
-                                 value=arg_value,
-                                 typename=type(arg_value).__name__,
-                                 values=arg_values)
-
-        if self._errors:
-            raise ArgumentValueError(str(self._errors))
-
-        return args
-
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+import inspect
+import itertools
+import functools
+
+from pytraits.support.errors import TypeConversionError, ArgumentValueError
+from pytraits.support.utils import get_func_name
+from pytraits.support.utils import get_signature
+
+
+__all__ = ["type_safe", "type_converted"]
+
+
+class ErrorMessage:
+    """
+    Encapsulates building of error message.
+    """
+    def __init__(self, main_msg, repeat_msg, get_func_name):
+        self.__errors = []
+        self.__get_func_name = get_func_name
+        self.__main_msg = main_msg
+        self.__repeat_msg = repeat_msg
+
+    def __bool__(self):
+        return bool(self.__errors)
+
+    def __str__(self):
+        msg = [self.__main_msg.format(self.__get_func_name)]
+        for error in self.__errors:
+            msg.append("   - " + self.__repeat_msg.format(**error))
+        return "\n".join(msg)
+
+    def set_main_messsage(self, msg):
+        self.__main_msg = msg
+
+    def set_repeat_message(self, msg):
+        self.__repeat_msg = msg
+
+    def add(self, **kwargs):
+        self.__errors.append(kwargs)
+
+    def reset(self):
+        self.__errors = []
+
+
+class type_safe:
+    """
+    Decorator to enforce type safety. It certainly kills some ducks
+    but allows us also to fail fast.
+
+    >>> @type_safe
+    ... def check(value: int, answer: bool, anything):
+    ...     return value, answer, anything
+    ...
+
+    >>> check("12", "false", True)
+    Traceback (most recent call last):
+    ...
+    TypeError: While calling check(value:int, answer:bool, anything):
+       - parameter 'value' had value '12' of type 'str'
+       - parameter 'answer' had value 'false' of type 'str'
+
+    >>> check(1000, True)
+    Traceback (most recent call last):
+    ...
+    TypeError: check() missing 1 required positional argument: 'anything'
+    """
+    def __init__(self, function):
+        self._function = function
+        functools.update_wrapper(self, function)
+        self.__signature = inspect.signature(function)
+        self._specs = inspect.getfullargspec(self._function)
+        self._self = None
+        self._errors = ErrorMessage(
+            'While calling {}:',
+            "parameter '{name}' had value '{value}' of type '{typename}'",
+            get_signature(function))
+
+    def __get__(self, instance, clazz):
+        """
+        Stores calling instances and returns this decorator object as function.
+        """
+        # In Python, every function is a property. Before Python invokes function,
+        # it must access the function using __get__, where it can deliver the calling
+        # object. After the __get__, function is ready for being invoked by __call__.
+        self._self = instance
+        return self
+
+    def iter_positional_args(self, args):
+        """
+        Yields type, name, value combination of function arguments.
+        """
+        # specs.args contains all arguments of the function. Loop here all
+        # argument names and their values putting them together. If there
+        # are arguments missing values, fill them with None.
+        for name, val in itertools.zip_longest(self._specs.args, args, fillvalue=None):
+            # __annotations__ is a dictionary of argument name and annotation.
+            # We accept empty annotations, in which case the argument has no
+            # type requirement.
+            yield self._function.__annotations__.get(name, None), name, val
+
+    def _analyze_args(self, args):
+        """
+        Invoked by __call__ in order to work with positional arguments.
+
+        This function does the actual work of evaluating arguments against
+        their annotations. Any deriving class can override this function
+        to do different kind of handling for the arguments. Overriding function
+        must return list of arguments that will be used to call the decorated
+        function.
+
+        @param args: Arguments given for the function.
+        @return same list of arguments given in parameter.
+        """
+        # TODO: inspect.Signature does quite lot of similar things. Figure
+        #       out, how to take advantage of that.
+        for arg_type, arg_name, arg_value in self.iter_positional_args(args):
+            if not arg_type or isinstance(arg_value, arg_type):
+                continue
+
+            self._errors.add(
+                typename=type(arg_value).__name__,
+                name=arg_name,
+                value=arg_value)
+
+        if self._errors:
+            raise TypeError(str(self._errors))
+
+        return args
+
+    def __match_arg_count(self, args):
+        """
+        Verifies that proper number of arguments are given to function.
+        """
+        # With default values this verification is bit tricky. In case
+        # given arguments match with number of arguments in function signature,
+        # we can proceed.
+        if len(args) == len(self._specs.args):
+            return True
+
+        # It's possible to have less arguments given than defined in function
+        # signature in case any default values exist.
+        if len(args) - len(self._specs.defaults or []) == len(self._specs.args):
+            return True
+
+        # When exceeding number of args, also check if function accepts
+        # indefinite number of positional arguments.
+        if len(args) > len(self._specs.args) and self._specs.varargs:
+            return True
+
+        # We got either too many arguments or too few.
+        return False
+
+    def __call__(self, *args, **kwargs):
+        """
+        Converts annotated types into proper type and calls original function.
+        """
+        self._errors.reset()
+
+        # Methods require instance of the class to be first argument. We
+        # stored it in __get__ and now add it to argument list so that
+        # function can be invoked correctly.
+        if self._self:
+            args = (self._self, ) + args
+
+        # Before doing any type checks, make sure argument count matches.
+        if self.__match_arg_count(args):
+            args = self._analyze_args(args)
+
+        return self._function(*args, **kwargs)
+
+
+class type_converted(type_safe):
+    """
+    Decorator to enforce types and do auto conversion to values.
+
+    >>> @type_converted
+    ... def convert(value: int, answer: bool, anything):
+    ...     return value, answer, anything
+    ...
+    >>> convert("12", "false", None)
+    (12, False, None)
+
+    >>> class Example:
+    ...     @type_converted
+    ...     def convert(self, value: int, answer: bool, anything):
+    ...       return value, answer, anything
+    ...
+    >>> Example().convert("12", 0, "some value")
+    (12, False, 'some value')
+
+    >>> Example().convert(None, None, None)
+    Traceback (most recent call last):
+    ...
+    pytraits.support.errors.TypeConversionError: While calling Example.convert(self, value:int, answer:bool, anything):
+       - got arg 'value' as 'None' of type 'NoneType' which cannot be converted to 'int'
+       - got arg 'answer' as 'None' of type 'NoneType' which cannot be converted to 'bool'
+    """
+    def __init__(self, function):
+        super().__init__(function)
+        self.__converters = {bool: self.boolean_conversion}
+        self._errors = ErrorMessage(
+            'While calling {}:',
+            "got arg '{name}' as '{value}' of type '{typename}' "
+            "which cannot be converted to '{expectedtype}'",
+            get_signature(function))
+
+    def convert(self, arg_type, arg_name, arg_value):
+        """
+        Converts argument to given type.
+        """
+        # If no type required, return value as is.
+        if arg_type is None:
+            return arg_value
+
+        try:
+            return self.__converters[arg_type](arg_value)
+        except KeyError:
+            return arg_type(arg_value)
+
+    def boolean_conversion(self, value):
+        """
+        Convert given value to boolean.
+
+        >>> conv = type_converted(lambda self: None)
+        >>> conv.boolean_conversion("True"), conv.boolean_conversion("false")
+        (True, False)
+
+        >>> conv.boolean_conversion(1), conv.boolean_conversion(0)
+        (True, False)
+        """
+        if isinstance(value, bool):
+            return value
+
+        elif isinstance(value, str):
+            if value.lower() == "true":
+                return True
+            if value.lower() == "false":
+                return False
+
+        elif isinstance(value, int):
+            if not value:
+                return False
+            if value == 1:
+                return True
+
+        raise TypeConversionError()  # This will be caught by convert method.
+
+    def _analyze_args(self, args):
+        """
+        Converts annotated types into proper type and calls original function.
+        """
+        self._errors.reset()
+        new_args = []
+
+        for arg_type, arg_name, arg_value in self.iter_positional_args(args):
+            try:
+                new_args.append(self.convert(arg_type, arg_name, arg_value))
+            except (TypeConversionError, TypeError):
+                self._errors.add(
+                    name=arg_name,
+                    value=arg_value,
+                    typename=type(arg_value).__name__,
+                    expectedtype=arg_type.__name__)
+
+        if self._errors:
+            raise TypeConversionError(str(self._errors))
+
+        return new_args
+
+
+class validation(type_safe):
+    """ Class to validate attributes against given values
+
+    >>> @validation
+    ... def show_number(number: (1, 2, 3, 5)):
+    ...     return number
+    ...
+    >>> show_number(1), show_number(2), show_number(3), show_number(5)
+    (1, 2, 3, 5)
+
+    >>> show_number(4)
+    Traceback (most recent call last):
+    ...
+    pytraits.support.errors.ArgumentValueError: While calling 'show_number':
+       - got arg 'number' as '4' of type 'int' which is not any of these values: (1, 2, 3, 5)
+
+    >>> show_number("5")
+    Traceback (most recent call last):
+    ...
+    pytraits.support.errors.ArgumentValueError: While calling 'show_number':
+       - got arg 'number' as '5' of type 'str' which is not any of these values: (1, 2, 3, 5)
+    """
+    def __init__(self, function):
+        super().__init__(function)
+        self.__function = function
+        self._errors = ErrorMessage(
+            "While calling '{}':",
+            "got arg '{name}' as '{value}' of type '{typename}' "
+            "which is not any of these values: {values}",
+            get_func_name(function))
+
+    def _analyze_args(self, args):
+        self._errors.reset()
+
+        for arg_values, arg_name, arg_value in self.iter_positional_args(args):
+            if not arg_values:
+                continue
+
+            arg_values = tuple([arg_values]) if not isinstance(arg_values, tuple) else arg_values
+            if arg_value not in arg_values:
+                self._errors.add(name=arg_name,
+                                 value=arg_value,
+                                 typename=type(arg_value).__name__,
+                                 values=arg_values)
+
+        if self._errors:
+            raise ArgumentValueError(str(self._errors))
+
+        return args
+
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## pytraits/support/singleton.py

 * *Ordering differences only*

```diff
@@ -1,69 +1,69 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from pytraits.support.errors import SingletonError
-
-
-class Singleton(type):
-    """ Turn the class to immutable singleton.
-
-    >>> class Example(object, metaclass=Singleton):
-    ...    pass
-    ...
-    >>> a = Example()
-    >>> b = Example()
-    >>> id(a) == id(b)
-    True
-
-    Having your instance as a singleton is faster than creating from scratch
-
-    >>> import timeit
-    >>> class MySingleton(object, metaclass=Singleton):
-    ...    def __init__(self):
-    ...        self._store = dict(one=1, two=2, three=3, four=4)
-    ...
-    >>> class NonSingleton:
-    ...    def __init__(self):
-    ...        self._store = dict(one=1, two=2, three=3, four=4)
-    ...
-    >>> #timeit.timeit(NonSingleton) > timeit.timeit(MySingleton)
-
-    After creating a singleton, data it is holding should not be changed.
-    There is a small enforcement done for these singletons to prevent modifying
-    the contents. With little effort it is doable, but don't do it. :)
-
-    >>> MySingleton().new_item = False
-    Traceback (most recent call last):
-    ...
-    pytraits.support.errors.SingletonError: Singletons are immutable!
-    """
-    def __call__(self, *args, **kwargs):
-        try:
-            return self.__instance
-        except AttributeError:
-            def immutable_object(*args):
-                raise SingletonError()
-
-            self.__instance = super().__call__(*args, **kwargs)
-            self.__setitem__ = immutable_object
-            self.__setattr__ = immutable_object
-            return self.__instance
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from pytraits.support.errors import SingletonError
+
+
+class Singleton(type):
+    """ Turn the class to immutable singleton.
+
+    >>> class Example(object, metaclass=Singleton):
+    ...    pass
+    ...
+    >>> a = Example()
+    >>> b = Example()
+    >>> id(a) == id(b)
+    True
+
+    Having your instance as a singleton is faster than creating from scratch
+
+    >>> import timeit
+    >>> class MySingleton(object, metaclass=Singleton):
+    ...    def __init__(self):
+    ...        self._store = dict(one=1, two=2, three=3, four=4)
+    ...
+    >>> class NonSingleton:
+    ...    def __init__(self):
+    ...        self._store = dict(one=1, two=2, three=3, four=4)
+    ...
+    >>> #timeit.timeit(NonSingleton) > timeit.timeit(MySingleton)
+
+    After creating a singleton, data it is holding should not be changed.
+    There is a small enforcement done for these singletons to prevent modifying
+    the contents. With little effort it is doable, but don't do it. :)
+
+    >>> MySingleton().new_item = False
+    Traceback (most recent call last):
+    ...
+    pytraits.support.errors.SingletonError: Singletons are immutable!
+    """
+    def __call__(self, *args, **kwargs):
+        try:
+            return self.__instance
+        except AttributeError:
+            def immutable_object(*args):
+                raise SingletonError()
+
+            self.__instance = super().__call__(*args, **kwargs)
+            self.__setitem__ = immutable_object
+            self.__setattr__ = immutable_object
+            return self.__instance
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## pytraits/support/utils.py

 * *Ordering differences only*

```diff
@@ -1,148 +1,148 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-import inspect
-
-
-def is_sysname(name: str):
-    """ Quick check if name is system specific.
-
-    When doing lot of introspection with functions and attributes, very often
-    arises a situation to check, if attribute name is following pattern used
-    by Python for system attributes. This simple function allows to identify
-    them in simple fashion without need to write same pattern everywhere.
-
-    >>> is_sysname("test")
-    False
-    >>> is_sysname("__test")
-    False
-    >>> is_sysname("__test__")
-    True
-    >>> is_sysname("_test_")
-    False
-    """
-    return name.startswith('__') and name.endswith('__')
-
-
-def is_container(obj):
-    """ Checks whether the object is container or not.
-
-    Container is considered an object, which includes other objects,
-    thus string is not qualified, even it implments iterator protocol.
-
-    >>> is_container("text")
-    False
-
-    >>> is_container(tuple())
-    True
-    """
-    if isinstance(obj, str):
-        return False
-
-    return hasattr(obj, '__iter__')
-
-
-def has_dict_protocol(obj):
-    """ Checks whether object supports dict protocol. """
-    return hasattr(obj, "__getitem__") and hasattr(obj, "__setitem__")
-
-
-def flatten(items):
-    """ Flatten the nested arrays into single one.
-
-    Example about list of lists.
-    >>> list(flatten([[1, 2], [3, 4]]))
-    [1, 2, 3, 4]
-
-    Example of deeply nested irregular list:
-    >>> list(flatten([[[1, 2]], [[[3]]], 4, 5, [[6, [7, 8]]]]))
-    [1, 2, 3, 4, 5, 6, 7, 8]
-
-    List of strings is handled properly too
-    >>> list(flatten(["one", "two", ["three", "four"]]))
-    ['one', 'two', 'three', 'four']
-    """
-    for subitem in items:
-        if is_container(subitem):
-            for item in flatten(subitem):
-                yield item
-        else:
-            yield subitem
-
-
-def get_signature(function):
-    """ Constructs signature of function.
-
-    >>> def test(arg, *args, **kwargs): pass
-    >>> get_signature(test)
-    'test(arg, *args, **kwargs)'
-
-    >>> class Test:
-    ...     def test(self, arg, *args, **kwargs): pass
-    ...
-    >>> get_signature(Test.test)
-    'Test.test(self, arg, *args, **kwargs)'
-    """
-    sig = inspect.signature(function)
-    return "{}{}".format(get_func_name(function), str(sig))
-
-
-def get_func_name(routine, fullname=True):
-    """ Returns name of the function as a string.
-
-    Full name examples, where we get the __qualname__.
-    >>> class Test:
-    ...     def test_method(self): pass
-    ...
-    ...     @classmethod
-    ...     def test_classmethod(cls): pass
-    ...
-    ...     @staticmethod
-    ...     def test_staticmethod(): pass
-    ...
-    >>> get_func_name(Test.test_method)
-    'Test.test_method'
-    >>> get_func_name(Test.test_classmethod)
-    'Test.test_classmethod'
-    >>> get_func_name(Test.test_staticmethod)
-    'Test.test_staticmethod'
-
-    Examples where we want to have just __name__.
-    >>> get_func_name(Test.test_method, fullname=False)
-    'test_method'
-    >>> get_func_name(Test.test_classmethod, fullname=False)
-    'test_classmethod'
-    >>> get_func_name(Test.test_staticmethod, fullname=False)
-    'test_staticmethod'
-
-    >>> def test_function(): pass
-    >>> get_func_name(test_function)
-    'test_function'
-    >>> get_func_name(test_function, fullname=False)
-    'test_function'
-    """
-    name_attr = '__qualname__' if fullname else '__name__'
-    try:
-        return getattr(routine, name_attr)
-    except AttributeError:
-        function = getattr(routine, '__func__', routine)
-        return function.__name__
-
-if __name__ == "__main__":
-    import doctest
-    doctest.testmod()
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+import inspect
+
+
+def is_sysname(name: str):
+    """ Quick check if name is system specific.
+
+    When doing lot of introspection with functions and attributes, very often
+    arises a situation to check, if attribute name is following pattern used
+    by Python for system attributes. This simple function allows to identify
+    them in simple fashion without need to write same pattern everywhere.
+
+    >>> is_sysname("test")
+    False
+    >>> is_sysname("__test")
+    False
+    >>> is_sysname("__test__")
+    True
+    >>> is_sysname("_test_")
+    False
+    """
+    return name.startswith('__') and name.endswith('__')
+
+
+def is_container(obj):
+    """ Checks whether the object is container or not.
+
+    Container is considered an object, which includes other objects,
+    thus string is not qualified, even it implments iterator protocol.
+
+    >>> is_container("text")
+    False
+
+    >>> is_container(tuple())
+    True
+    """
+    if isinstance(obj, str):
+        return False
+
+    return hasattr(obj, '__iter__')
+
+
+def has_dict_protocol(obj):
+    """ Checks whether object supports dict protocol. """
+    return hasattr(obj, "__getitem__") and hasattr(obj, "__setitem__")
+
+
+def flatten(items):
+    """ Flatten the nested arrays into single one.
+
+    Example about list of lists.
+    >>> list(flatten([[1, 2], [3, 4]]))
+    [1, 2, 3, 4]
+
+    Example of deeply nested irregular list:
+    >>> list(flatten([[[1, 2]], [[[3]]], 4, 5, [[6, [7, 8]]]]))
+    [1, 2, 3, 4, 5, 6, 7, 8]
+
+    List of strings is handled properly too
+    >>> list(flatten(["one", "two", ["three", "four"]]))
+    ['one', 'two', 'three', 'four']
+    """
+    for subitem in items:
+        if is_container(subitem):
+            for item in flatten(subitem):
+                yield item
+        else:
+            yield subitem
+
+
+def get_signature(function):
+    """ Constructs signature of function.
+
+    >>> def test(arg, *args, **kwargs): pass
+    >>> get_signature(test)
+    'test(arg, *args, **kwargs)'
+
+    >>> class Test:
+    ...     def test(self, arg, *args, **kwargs): pass
+    ...
+    >>> get_signature(Test.test)
+    'Test.test(self, arg, *args, **kwargs)'
+    """
+    sig = inspect.signature(function)
+    return "{}{}".format(get_func_name(function), str(sig))
+
+
+def get_func_name(routine, fullname=True):
+    """ Returns name of the function as a string.
+
+    Full name examples, where we get the __qualname__.
+    >>> class Test:
+    ...     def test_method(self): pass
+    ...
+    ...     @classmethod
+    ...     def test_classmethod(cls): pass
+    ...
+    ...     @staticmethod
+    ...     def test_staticmethod(): pass
+    ...
+    >>> get_func_name(Test.test_method)
+    'Test.test_method'
+    >>> get_func_name(Test.test_classmethod)
+    'Test.test_classmethod'
+    >>> get_func_name(Test.test_staticmethod)
+    'Test.test_staticmethod'
+
+    Examples where we want to have just __name__.
+    >>> get_func_name(Test.test_method, fullname=False)
+    'test_method'
+    >>> get_func_name(Test.test_classmethod, fullname=False)
+    'test_classmethod'
+    >>> get_func_name(Test.test_staticmethod, fullname=False)
+    'test_staticmethod'
+
+    >>> def test_function(): pass
+    >>> get_func_name(test_function)
+    'test_function'
+    >>> get_func_name(test_function, fullname=False)
+    'test_function'
+    """
+    name_attr = '__qualname__' if fullname else '__name__'
+    try:
+        return getattr(routine, name_attr)
+    except AttributeError:
+        function = getattr(routine, '__func__', routine)
+        return function.__name__
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
```

## pytraits/support/__init__.py

 * *Ordering differences only*

```diff
@@ -1,26 +1,26 @@
-#!/usr/bin/python -tt
-# -*- coding: utf-8 -*-
-'''
-   Copyright 2014-2015 Teppo PerÃ¤
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-'''
-
-from .singleton import Singleton
-from .inspector import Inspector
-from .factory import Factory
-from .magic import type_safe, type_converted
-from .utils import flatten, is_sysname, get_func_name
-
-__all__ = ["Singleton", "Inspector", "Factory", "flatten", "type_safe",
-           "type_converted", "is_sysname", "errors", "get_func_name"]
+#!/usr/bin/python -tt
+# -*- coding: utf-8 -*-
+'''
+   Copyright 2014-2015 Teppo PerÃ¤
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+'''
+
+from .singleton import Singleton
+from .inspector import Inspector
+from .factory import Factory
+from .magic import type_safe, type_converted
+from .utils import flatten, is_sysname, get_func_name
+
+__all__ = ["Singleton", "Inspector", "Factory", "flatten", "type_safe",
+           "type_converted", "is_sysname", "errors", "get_func_name"]
```

## Comparing `py3traits-1.2.0.dist-info/DESCRIPTION.rst` & `py3traits-1.2.1.dist-info/METADATA`

 * *Files 19% similar despite different names*

```diff
@@ -1,7 +1,29 @@
+Metadata-Version: 2.1
+Name: py3traits
+Version: 1.2.1
+Summary: Trait support for Python 3
+Home-page: https://github.com/Debith/py3traits
+Author: Teppo PerÃÂ¤
+Author-email: debith-dev@outlook.com
+License: Apache License 2
+Keywords: traits
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: BSD License
+Classifier: Operating System :: Unix
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.3
+Classifier: Programming Language :: Python :: 3.4
+Classifier: Topic :: Utilities
+License-File: LICENSE
+License-File: AUTHORS.rst
+
 ===============================
 py3traits
 ===============================
 
 | |docs| |travis| |downloads| |wheel| |pyversions|
 
 .. |docs| image:: https://readthedocs.org/projects/py3traits/badge/
@@ -60,17 +82,22 @@
 
 Look for examples from examples folder.
 
 
 Changelog
 =========
 
+1.2.1 (2015-07-08)
+------------------
+  - Added "Motivation" section to documentation to help to discover use cases.
+
 1.2.0 (2015-07-08)
 ------------------
-  - New feature: Precompiled functions can be used with properties
+  - New feature: Precompiled (builtin) functions can be used with properties
+  - New feature: Precompiled (builtin) functions can be used as traits
   - New feature: @validation decorator for validating arguments by value
   - New feature: Factory class for object creation
   - Improving feature: @type_safe and @type_converted wraps functions properly
   - Fixed homepage link which was pointing to Python 2 version
   - Added back the missing github link in documentation
   - Done a major overhaul for the core to better support adding new features
   - Many other bigger or smaller improvements
@@ -182,9 +209,7 @@
   - Added apache 2.0 license to all files
   - Set the character set as utf-8 for all files
 
 0.1.0 Initial Version
 ---------------------
   - prepared files for Python 2.x
   - prepared files for Python 3.x
-
-
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## Comparing `py3traits-1.2.0.dist-info/RECORD` & `py3traits-1.2.1.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,33 +1,33 @@
-py3traits-1.2.0.dist-info/DESCRIPTION.rst,sha256=VWNPW071x3vy8iutDVC_fYgrOPC07oRGINkYxNF6v8g,6409
-py3traits-1.2.0.dist-info/METADATA,sha256=D_BGtuVP8nGt_Nb7VPGor3EEsPhp4Bm4sTxDML_Pcqc,7129
-py3traits-1.2.0.dist-info/metadata.json,sha256=JPQIarGJGng5pMCRGAtSVSZGJcpuc8JkxYi7lpaKyQo,848
-py3traits-1.2.0.dist-info/RECORD,,
-py3traits-1.2.0.dist-info/top_level.txt,sha256=aL4g5G5v4TnfIejFgVr406YOZ2XMWe2SCcquhgqA-4s,9
-py3traits-1.2.0.dist-info/WHEEL,sha256=56WjMPRUEpmb30QaTzVbQCpri5lzKGby5HLDkAMQeIU,116
-pytraits/combiner.py,sha256=ig50hoiP6PNK1b7HJiBv2kMNyJ3hnLl0ORKjdTZzkQ8,1735
-pytraits/extendable.py,sha256=edsOT9ygFEZZ0ezJYOp9VV3RH_anPMkedXmmhC7akoA,2285
-pytraits/setproperty.py,sha256=HA8Z3UysW80PQEeXdoFMWajObjgBQeFgXcN2qRr4tX8,3461
-pytraits/trait_composer.py,sha256=b3VrvpCIoaZAkqIWjy5n0pZRPur0jKlklNx3OiRVOpc,2111
-pytraits/__init__.py,sha256=UoHxbeIkSDjj1Q9-EltaHlhzvK-HOPjuHraQAhm7tJc,1083
-pytraits/core/__init__.py,sha256=7vF__Q-8HdocqbvHE9AaLXXuY3iRxDcp2h47cDOrLj8,217
-pytraits/core/base/inspectors.py,sha256=BQvKc_1c7UkCXw_hAqNGUvkDpG4diFtvp6fez1ioigw,1873
-pytraits/core/base/__init__.py,sha256=BAXrGJaACE31TJizdYIvYv3LqBM-Er4UcVmu_4Vv_ig,1020
-pytraits/core/composing/compiler.py,sha256=pu7xJUe4nOGD_vOtMM4YZs40EEdxfqeQD2YMVBSFG6U,3215
-pytraits/core/composing/composer.py,sha256=EnEU7hcdBVd85Fn-jKi3qvGv7ogK5tV8AoUZWrw6fcA,5844
-pytraits/core/composing/resolutions.py,sha256=xQoIBGPgrfhdujSIgIctMR7rSV0QLkPyUmyLAa49vic,1741
-pytraits/core/composing/traits.py,sha256=XjmSNyZPF3v92xt4SLsiJ7W-rbunl5_ucIdyZwVG-34,3439
-pytraits/core/composing/__init__.py,sha256=72kSmxdmBNJpzEEos3hzIpReFQEbE_9jfSosccjH22M,857
-pytraits/core/primitives/class_object.py,sha256=VTMRosNnMXhKmazthmwIt3aMkdfBSolPVRmFCtQ0cec,1583
-pytraits/core/primitives/instance_object.py,sha256=l3EhuoASOaGbpslj3oaehBFuzL9tb0VifjbwBYbjOOM,2942
-pytraits/core/primitives/property_object.py,sha256=yVuzGvKRA7MdheJAB1eRyWHYu1nexmAEBY4ZDjKWKpk,1796
-pytraits/core/primitives/routine_object.py,sha256=ht9Nuoh8LMH0LbaGEuQ5I5oSYVMZwkGcvuPBZ5CzeyU,4018
-pytraits/core/primitives/trait_object.py,sha256=wOOAFnvbXbOe56ce4Ymq3XD9VNKVrxyRu0L6NVDiI2s,1373
-pytraits/core/primitives/unidentified_object.py,sha256=DltjAx383EX3J59k8RmZE0UIjtNZs4LI7oHk9YwIG1Y,951
-pytraits/core/primitives/__init__.py,sha256=9Z9F7y0CHiNNDWvme7a5y9oydRI4zAGxZew5zIv5NZw,1799
-pytraits/support/errors.py,sha256=EK_DChhZtMEZ9GtCfJjMw7yiVmH0QE_LlGzcUzsNrXQ,1863
-pytraits/support/factory.py,sha256=1tmyjAJRbNGm4qH5qekrD8fyfiee4pf59l7wJaVQpCo,5807
-pytraits/support/inspector.py,sha256=tum4G8M6SvmaD91EQQgBcE3HkeLmFf6eRPUaxd-KfzY,9850
-pytraits/support/magic.py,sha256=O7-_JM2jUY6sEX5KhSJhEP0lnfvm_Ab1ulSQ5v6CS9c,12085
-pytraits/support/singleton.py,sha256=B7ATT8Zqmv98SGOc1Sp7U1_VVhuO-fO7vr0IVgCy9JA,2302
-pytraits/support/utils.py,sha256=z4909xzVCKrPaiDBMhHI1IxZEvl7819wWF3IWUNvV2M,4378
-pytraits/support/__init__.py,sha256=63ppMLtvhcMWvTVwPH3vh57_VjH2hyMpUklulgjP03g,1005
+pytraits/__init__.py,sha256=iqiN9kYgNgXGE5KUdIkhFCR7jAp3F2A2pmVYCay8188,1056
+pytraits/combiner.py,sha256=tw5fuU234taeC7_Uzs6sYlNKD7tyy8pDc72oLa5Hymo,1678
+pytraits/extendable.py,sha256=nOsvC7Klc-9Z2PwbYdcELMq5OY3ZcBWatzNZcES4Zh4,2216
+pytraits/setproperty.py,sha256=epeRLLYWP-YN3E5INIBZic2LE-WYrZ-nQwrxFjG4q18,3362
+pytraits/trait_composer.py,sha256=Vo6GaEY3lr-Pmf8hxPQeV9AZ8aSYcLkFXG_a3TocEz8,2046
+pytraits/core/__init__.py,sha256=TrB4nGulcrV39yC1XS-j7xvLp7M_-Z9cDTnCvnZcRqY,209
+pytraits/core/base/__init__.py,sha256=eGwh_cIe8GuQ2iddJEtEiNQ13X1vnaa-voNUoNSy2mc,990
+pytraits/core/base/inspectors.py,sha256=nVLNZvkImb1pAijFYiZIa5Ok0OSamxInwaL9UJ5lGJY,1814
+pytraits/core/composing/__init__.py,sha256=SJll2aWk7Erfikv97ekXQsGL4BABppoSOU4BeFLRijE,835
+pytraits/core/composing/compiler.py,sha256=W0gCH8-90jPHP2sEqkba_a7wTM8lqY7II8WGYQqN_EM,3262
+pytraits/core/composing/composer.py,sha256=-nbhFTLI2XPDTyqQIHj3FEisl6zxj14VdxJvtP3y8Kk,5705
+pytraits/core/composing/resolutions.py,sha256=X_WgfxZAK_Celgzz5dKzxdAWmlIsdRAagUlTy9IrPD8,1690
+pytraits/core/composing/traits.py,sha256=aZXNZOMjXMN-uXFoY2JqtRFcbSUVj5NHLeXdRSC62Cg,3345
+pytraits/core/primitives/__init__.py,sha256=ORDViMx8n5hCHnTFbe7D-K8LIblQZY2uxnMbTIKo9eA,1750
+pytraits/core/primitives/class_object.py,sha256=rjFJoDF_Eg2jNyj16dUvrBdek9ohI7tenjwLoLy4Ync,1530
+pytraits/core/primitives/instance_object.py,sha256=cywofH8wIHe30b-fbgows_cqmDXjy7qfEsQ8NzOFC40,2861
+pytraits/core/primitives/property_object.py,sha256=4QzvG6cDkIzA9T78djDWyS199Sk49rBuYtd8-y9CPuE,1743
+pytraits/core/primitives/routine_object.py,sha256=thubzm23nuXvtbKpUr9NK9dIpfhhNUth0tEfq9mCDaM,3894
+pytraits/core/primitives/trait_object.py,sha256=9YqgW_KsYQWf5WehFPLwypr2rYzV04brli0CQpIxfgM,1326
+pytraits/core/primitives/unidentified_object.py,sha256=MNQpfKQsr4odtODyXt3EVEHxda5vd6UZ5CMm1qewy2E,920
+pytraits/support/__init__.py,sha256=tDE-oPBZcq8eSWIfE7hDJE30yB4vBoCrMAD19MxAMJI,979
+pytraits/support/errors.py,sha256=n_suAnR2QaOXtMnkhj_deZwZOOB-74JQp80BsAw9oOg,1819
+pytraits/support/factory.py,sha256=iL74_0k_UYrfcwcQqJQPPd7EdTjFXkemSQ6qi42uc3I,5650
+pytraits/support/inspector.py,sha256=GO8O8k5AV47WwsAmr3ggLr8aqx9qvzDnjl0_T9qCsxg,9559
+pytraits/support/magic.py,sha256=w9B0iIHra8uuDhx8Af-Ps8fLnxVFwkqzFuWTDg786qs,11743
+pytraits/support/singleton.py,sha256=Ol8w6SjnhHHIlH_jAX2fvKktG_AjGuaOYfyXmNifVZ4,2233
+pytraits/support/utils.py,sha256=IhPRXouncilN_vQLyMpK4nJxzAQ8oCBoxtPk3MrKNrw,4230
+py3traits-1.2.1.dist-info/AUTHORS.rst,sha256=RjBaPgrp9ERGYSf4T1TMMOH5Bt6q70tEtwRyz01BeA0,70
+py3traits-1.2.1.dist-info/LICENSE,sha256=uyjEjj4HgWbpHPwrbbf_67iglzueI7PfBgVhKS2Naew,10140
+py3traits-1.2.1.dist-info/METADATA,sha256=euJRHlN7EvLvz3rQ085-xk6CzjNRx-1scMG5Yg_M4ok,7356
+py3traits-1.2.1.dist-info/WHEEL,sha256=bb2Ot9scclHKMOLDEHY6B2sicWOgugjFKaJsT7vwMQo,110
+py3traits-1.2.1.dist-info/top_level.txt,sha256=aL4g5G5v4TnfIejFgVr406YOZ2XMWe2SCcquhgqA-4s,9
+py3traits-1.2.1.dist-info/RECORD,,
```

